import Development.Shake
import Development.Shake.FilePath
import System.Directory (createDirectoryLink, removePathForcibly, doesDirectoryExist)
import System.Info (os)
import System.Process (readProcess)
import Data.List (isInfixOf)
import Data.Maybe (listToMaybe)
import Data.Char (isSpace)
import Control.Monad (when)

-- | Trim whitespace from both ends of a string
strip :: String -> String
strip = dropWhile isSpace . reverse . dropWhile isSpace . reverse

-- | Extract the mangled MAlonzo name for processCommand from generated Haskell
-- Looks for pattern: "d_processCommand_XX ::"
extractMangledName :: String -> Maybe String
extractMangledName content =
    listToMaybe [name | line <- lines content,
                        "processCommand" `isInfixOf` line,
                        "::" `isInfixOf` line,
                        let name = takeWhile (/= ' ') (dropWhile (== ' ') line),
                        "d_processCommand_" `isInfixOf` name]

-- | Extract the function name currently used in the Haskell shim
-- Looks for pattern: "Agda.d_processCommand_XX"
extractShimName :: String -> Maybe String
extractShimName content =
    listToMaybe [cleaned | line <- lines content,
                           "Agda." `isInfixOf` line,
                           "processCommand" `isInfixOf` line,
                           let parts = words line,
                           name <- parts,
                           "Agda.d_processCommand_" `isInfixOf` name,
                           let cleaned = drop 5 name, -- drop "Agda."
                           "d_processCommand_" `isInfixOf` cleaned]

-- | Check that the Haskell shim uses the correct mangled name
checkFFIName :: FilePath -> FilePath -> Action ()
checkFFIName malonzoFile shimFile = do
    malonzoContent <- liftIO $ readFile malonzoFile
    shimContent <- liftIO $ readFile shimFile

    case (extractMangledName malonzoContent, extractShimName shimContent) of
        (Just generatedName, Just shimName) ->
            when (generatedName /= shimName) $ do
                putError $ unlines
                    [ ""
                    , "════════════════════════════════════════════════════════════════"
                    , "ERROR: MAlonzo function name mismatch!"
                    , "════════════════════════════════════════════════════════════════"
                    , ""
                    , "  Generated by Agda:  " ++ generatedName
                    , "  Currently in shim:  " ++ shimName
                    , ""
                    , "The Agda code structure changed, causing MAlonzo to generate"
                    , "a different mangled name. Update the Haskell shim to match."
                    , ""
                    , "To fix, run:"
                    , "  sed -i 's/" ++ shimName ++ "/" ++ generatedName ++ "/g' " ++ shimFile
                    , ""
                    , "Then rebuild:"
                    , "  cabal run shake -- build"
                    , ""
                    , "════════════════════════════════════════════════════════════════"
                    , ""
                    ]
                error "FFI name mismatch - see above for fix instructions"
        (Nothing, _) ->
            putWarn "Could not extract mangled name from MAlonzo output (might be OK if function signature changed)"
        (_, Nothing) ->
            putWarn "Could not extract function name from Haskell shim (might be OK if imports changed)"

main :: IO ()
main = shakeArgs shakeOptions{shakeFiles="build", shakeThreads=0, shakeChange=ChangeModtimeAndDigest} $ do

    phony "build" $ do
        need ["build/aletheia"]

    phony "build-agda" $ do
        need ["build/MAlonzo/Code/Aletheia/Main.hs"]

    phony "build-haskell" $ do
        need ["build/aletheia"]

    phony "check-properties" $ do
        putInfo "Type-checking Properties modules (proofs)..."
        cmd_ (Cwd "src") "agda" ["+RTS", "-N32", "-RTS", "Aletheia/Parser/Properties.agda"]
        cmd_ (Cwd "src") "agda" ["+RTS", "-N32", "-RTS", "Aletheia/CAN/Encoding/Properties.agda"]
        cmd_ (Cwd "src") "agda" ["+RTS", "-N32", "-RTS", "Aletheia/DBC/Properties.agda"]
        cmd_ (Cwd "src") "agda" ["+RTS", "-N32", "-RTS", "Aletheia/Protocol/JSON/Properties.agda"]
        cmd_ (Cwd "src") "agda" ["+RTS", "-N32", "-RTS", "Aletheia/LTL/Bisimilarity.agda"]
        putInfo "All Properties modules type-checked successfully!"

    phony "install-python" $ do
        need ["build/aletheia"]
        cmd_ (Cwd "python") "pip3 install -e ."

    phony "clean" $ do
        putInfo "Cleaning build artifacts..."
        removeFilesAfter "build" ["//*"]
        removeFilesAfter "src" ["//*.agdai"]
        removeFilesAfter "haskell-shim" ["//MAlonzo"]
        cmd_ (Cwd "haskell-shim") "cabal clean"

    "build/MAlonzo/Code/Aletheia/Main.hs" %> \out -> do
        agdaSources <- getDirectoryFiles "src" ["//*.agda"]
        need (map ("src" </>) agdaSources)

        -- Shake's ChangeModtimeAndDigest tracks file content hashes
        -- When any .agda source changes, Shake detects it and re-runs this rule
        -- Agda will then update .agdai files as needed based on source changes
        putInfo "Compiling Agda to Haskell (this may take a few minutes)..."
        cmd_ (Cwd "src")
            "agda"
            "--compile"
            "--compile-dir=../build"
            "--ghc-dont-call-ghc"
            "Aletheia/Main.agda"

        exists <- doesFileExist out
        if exists
            then do
                putInfo $ "MAlonzo output generated: " ++ out
                -- Check that Haskell shim uses correct mangled FFI name
                checkFFIName out "haskell-shim/src/Main.hs"
            else error $ "Agda compilation failed: " ++ out ++ " not created"

    phony "create-symlink" $ do
        need ["build/MAlonzo/Code/Aletheia/Main.hs"]

        let symlinkPath = "haskell-shim/MAlonzo"
        let target = "../build/MAlonzo"

        -- Remove existing symlink/directory if present
        liftIO $ removePathForcibly symlinkPath

        putInfo $ "Creating symlink: " ++ symlinkPath ++ " -> " ++ target

        if os == "mingw32"
            then cmd_ "cmd" "/c" "mklink /D" symlinkPath target
            else liftIO $ createDirectoryLink target symlinkPath

    "build/aletheia" %> \out -> do
        -- Depend on all MAlonzo generated Haskell files, not just Main.hs
        -- This ensures Shake detects any changes from Agda compilation
        malonzoFiles <- getDirectoryFiles "build" ["MAlonzo//**/*.hs"]
        need (map ("build" </>) malonzoFiles)

        need ["create-symlink"]  -- Depend on phony target, not directory
        need ["haskell-shim/src/Main.hs", "haskell-shim/aletheia.cabal"]

        -- Force Cabal to rebuild when MAlonzo files change
        -- Touch Main.hs to invalidate Cabal's cache, then clean object files
        putInfo "Invalidating Cabal cache (touch Main.hs)..."
        cmd_ "touch" "haskell-shim/src/Main.hs"

        -- Delete intermediate build artifacts to force relink
        putInfo "Cleaning Cabal build artifacts..."
        cmd_ (Cwd "haskell-shim") "rm" "-rf" "dist-newstyle/build/x86_64-linux/ghc-9.6.7/aletheia-0.1.0.0/x/aletheia"

        putInfo "Building Haskell executable..."
        cmd_ (Cwd "haskell-shim") "cabal" "build" "-j" "exe:aletheia"

        putInfo "Copying binary..."
        cmd_ (Cwd "haskell-shim") Shell
            "cp $(cabal list-bin exe:aletheia) ../build/aletheia"

        putInfo $ "Binary created: " ++ out
