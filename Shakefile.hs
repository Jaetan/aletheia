import Development.Shake
import Development.Shake.FilePath
import System.Directory (createDirectoryLink, removePathForcibly,
                         getHomeDirectory, createDirectoryIfMissing,
                         removeDirectoryRecursive)
import System.Info (os)
import System.Environment (lookupEnv)
import System.Exit (ExitCode(..))
import Data.List (isInfixOf, isPrefixOf)
import Data.Maybe (listToMaybe)
import Data.Char (isSpace)
import Control.Monad (when, unless, forM_)
import GHC.Conc (getNumProcessors)

-- | Trim whitespace from both ends of a string
strip :: String -> String
strip = dropWhile isSpace . reverse . dropWhile isSpace . reverse

-- | Extract the mangled MAlonzo name for processJSONLine from generated Haskell
-- Looks for pattern: "d_processJSONLine_XX ::"
extractMangledName :: String -> Maybe String
extractMangledName content =
    listToMaybe [name | line <- lines content,
                        "processJSONLine" `isInfixOf` line,
                        "::" `isInfixOf` line,
                        let name = takeWhile (/= ' ') (dropWhile (== ' ') line),
                        "d_processJSONLine_" `isInfixOf` name]

-- | Extract the function name currently used in the FFI wrapper
-- Looks for pattern: "Agda.d_processJSONLine_XX"
extractFFIName :: String -> Maybe String
extractFFIName content =
    listToMaybe [cleaned | line <- lines content,
                           "Agda." `isInfixOf` line,
                           "processJSONLine" `isInfixOf` line,
                           let parts = words line,
                           name <- parts,
                           "Agda.d_processJSONLine_" `isInfixOf` name,
                           let cleaned = drop 5 name, -- drop "Agda."
                           "d_processJSONLine_" `isInfixOf` cleaned]

-- | Check that the FFI wrapper uses the correct mangled name
checkFFIName :: FilePath -> FilePath -> Action ()
checkFFIName malonzoFile ffiFile = do
    malonzoContent <- liftIO $ readFile malonzoFile
    ffiContent <- liftIO $ readFile ffiFile

    case (extractMangledName malonzoContent, extractFFIName ffiContent) of
        (Just generatedName, Just ffiName) ->
            when (generatedName /= ffiName) $ do
                putError $ unlines
                    [ ""
                    , "════════════════════════════════════════════════════════════════"
                    , "ERROR: MAlonzo function name mismatch!"
                    , "════════════════════════════════════════════════════════════════"
                    , ""
                    , "  Generated by Agda:  " ++ generatedName
                    , "  Currently in FFI:   " ++ ffiName
                    , ""
                    , "The Agda code structure changed, causing MAlonzo to generate"
                    , "a different mangled name. Update the FFI wrapper to match."
                    , ""
                    , "To fix, run:"
                    , "  sed -i 's/" ++ ffiName ++ "/" ++ generatedName ++ "/g' " ++ ffiFile
                    , ""
                    , "Then rebuild:"
                    , "  cabal run shake -- build"
                    , ""
                    , "════════════════════════════════════════════════════════════════"
                    , ""
                    ]
                error "FFI name mismatch - see above for fix instructions"
        (Nothing, _) ->
            putWarn "Could not extract mangled name from MAlonzo output (might be OK if function signature changed)"
        (_, Nothing) ->
            putWarn "Could not extract function name from FFI wrapper (might be OK if imports changed)"

-- | Get GHC runtime .so dependencies for a shared library.
-- Runs ldd and filters for libraries under GHC's lib directory.
getGhcDeps :: FilePath -> Action [FilePath]
getGhcDeps soPath = do
    Stdout ghcLibDir <- cmd "ghc" "--print-libdir"
    let ghcBase = strip ghcLibDir
    Stdout lddOutput <- cmd "ldd" soPath
    let deps = [ resolvedPath
               | line <- lines lddOutput
               , let ws = words line
               , length ws >= 3
               , ws !! 1 == "=>"
               , let resolvedPath = ws !! 2
               , ghcBase `isPrefixOf` resolvedPath
               ]
    return deps

-- | Check that patchelf and Python 3.12+ are available.
checkPrerequisites :: Action ()
checkPrerequisites = do
    Exit patchelfCode <- cmd Shell "command -v patchelf >/dev/null 2>&1"
    case patchelfCode of
        ExitSuccess -> return ()
        ExitFailure _ -> error $ unlines
            [ "patchelf is required for install but not found."
            , "Install it with:"
            , "  Ubuntu/Debian: sudo apt install patchelf"
            , "  macOS:         brew install patchelf"
            , "  Fedora:        sudo dnf install patchelf"
            ]
    Exit pyCode <- cmd Shell "python3 -c 'import sys; sys.exit(0 if sys.version_info >= (3,12) else 1)'"
    case pyCode of
        ExitSuccess -> return ()
        ExitFailure _ -> error "Python 3.12+ is required. Check your python3 version."

main :: IO ()
main = shakeArgs shakeOptions{shakeFiles="build", shakeThreads=0, shakeChange=ChangeModtimeAndDigest} $ do

    phony "build" $ do
        need ["build/libaletheia-ffi.so"]

    phony "build-agda" $ do
        need ["build/MAlonzo/Code/Aletheia/Main.hs"]

    phony "build-haskell" $ do
        need ["build/libaletheia-ffi.so"]

    phony "check-properties" $ do
        putInfo "Type-checking Properties modules (proofs)..."
        cores <- liftIO getNumProcessors
        let rtsFlags = ["+RTS", "-N" ++ show cores, "-RTS"]
        let agdaWithRTS mod' = cmd_ (Cwd "src") "agda" (rtsFlags ++ [mod'])
        -- Parser and protocol proofs
        agdaWithRTS "Aletheia/Parser/Properties.agda"
        agdaWithRTS "Aletheia/Protocol/JSON/Properties.agda"
        -- CAN encoding and batch proofs
        agdaWithRTS "Aletheia/CAN/Encoding/Properties.agda"
        agdaWithRTS "Aletheia/CAN/Batch/Properties.agda"
        -- DBC proofs
        agdaWithRTS "Aletheia/DBC/Properties.agda"
        -- LTL proofs (bisimilarity transitively checks CoalgebraBisim and StepResultBisim)
        agdaWithRTS "Aletheia/LTL/JSON/Properties.agda"
        agdaWithRTS "Aletheia/LTL/Bisimilarity.agda"
        putInfo "All Properties modules type-checked successfully!"

    phony "install-python" $ do
        need ["build/libaletheia-ffi.so"]
        cmd_ (Cwd "python") "pip3 install -e ."

    phony "clean" $ do
        putInfo "Cleaning build artifacts..."
        removeFilesAfter "build" ["//*"]
        removeFilesAfter "src" ["//*.agdai"]
        removeFilesAfter "haskell-shim" ["//MAlonzo"]
        cmd_ (Cwd "haskell-shim") "cabal clean"

    "build/MAlonzo/Code/Aletheia/Main.hs" %> \out -> do
        agdaSources <- getDirectoryFiles "src" ["//*.agda"]
        need (map ("src" </>) agdaSources)

        -- Shake's ChangeModtimeAndDigest tracks file content hashes
        -- When any .agda source changes, Shake detects it and re-runs this rule
        -- Agda will then update .agdai files as needed based on source changes
        putInfo "Compiling Agda to Haskell (this may take a few minutes)..."
        cores <- liftIO getNumProcessors
        cmd_ (Cwd "src")
            "agda"
            "+RTS" ("-N" ++ show cores) "-RTS"
            "--compile"
            "--compile-dir=../build"
            "--ghc-dont-call-ghc"
            "Aletheia/Main.agda"

        exists <- doesFileExist out
        if exists
            then do
                putInfo $ "MAlonzo output generated: " ++ out
                -- Check that FFI wrapper uses correct mangled name
                checkFFIName out "haskell-shim/src/AletheiaFFI.hs"
            else error $ "Agda compilation failed: " ++ out ++ " not created"

    phony "create-symlink" $ do
        need ["build/MAlonzo/Code/Aletheia/Main.hs"]

        let symlinkPath = "haskell-shim/MAlonzo"
        let target = "../build/MAlonzo"

        -- Remove existing symlink/directory if present
        liftIO $ removePathForcibly symlinkPath

        putInfo $ "Creating symlink: " ++ symlinkPath ++ " -> " ++ target

        if os == "mingw32"
            then cmd_ "cmd" "/c" "mklink /D" symlinkPath target
            else liftIO $ createDirectoryLink target symlinkPath

    "build/libaletheia-ffi.so" %> \out -> do
        -- Depend on all MAlonzo generated Haskell files
        -- This ensures Shake detects any changes from Agda compilation
        malonzoFiles <- getDirectoryFiles "build" ["MAlonzo//**/*.hs"]
        need (map ("build" </>) malonzoFiles)

        need ["create-symlink"]  -- Depend on phony target, not directory
        need ["haskell-shim/src/AletheiaFFI.hs", "haskell-shim/aletheia.cabal"]

        -- Force Cabal to rebuild when MAlonzo files change
        -- Touch AletheiaFFI.hs to invalidate Cabal's cache
        putInfo "Invalidating Cabal cache (touch AletheiaFFI.hs)..."
        cmd_ "touch" "haskell-shim/src/AletheiaFFI.hs"

        -- Delete intermediate build artifacts to force relink
        putInfo "Cleaning Cabal build artifacts..."
        cmd_ (Cwd "haskell-shim") "rm" "-rf" "dist-newstyle/build/x86_64-linux/ghc-9.6.7/aletheia-0.3.0.0/f/aletheia-ffi"

        putInfo "Building FFI shared library..."
        cmd_ (Cwd "haskell-shim") "cabal" "build" "-j" "aletheia-ffi"

        -- Find and copy the built .so file
        Stdout soPath <- cmd (Cwd "haskell-shim") Shell
            "find dist-newstyle -name 'libaletheia-ffi.so' -type f | head -1"
        let trimmedPath = strip soPath
        if null trimmedPath
            then error "Could not find libaletheia-ffi.so in dist-newstyle"
            else do
                cmd_ (Cwd "haskell-shim") "cp" trimmedPath ("../" ++ out)
                putInfo $ "Shared library created: " ++ out

    -- =========================================================================
    -- Install / Uninstall targets
    -- =========================================================================

    phony "install" $ do
        need ["build/libaletheia-ffi.so"]

        -- Read PREFIX (default: ~/.local)
        home <- liftIO getHomeDirectory
        prefixEnv <- liftIO $ lookupEnv "PREFIX"
        let prefix = maybe (home </> ".local") id prefixEnv
        configShellEnv <- liftIO $ lookupEnv "CONFIGURE_SHELL"
        let configShell = configShellEnv == Just "1"

        -- Check prerequisites
        checkPrerequisites

        let libDir     = prefix </> "lib" </> "aletheia"
        let docDir     = prefix </> "share" </> "doc" </> "aletheia"
        let exampleDir = prefix </> "share" </> "aletheia" </> "examples"
        let venvDir    = libDir </> "venv"
        let venvPython = venvDir </> "bin" </> "python3"
        let venvPip    = venvDir </> "bin" </> "pip"

        -- Create directory tree
        putInfo $ "Installing to " ++ prefix ++ " ..."
        liftIO $ createDirectoryIfMissing True libDir
        liftIO $ createDirectoryIfMissing True docDir
        liftIO $ createDirectoryIfMissing True exampleDir

        -- Copy main shared library
        putInfo "Copying shared library..."
        cmd_ "cp" "build/libaletheia-ffi.so" libDir

        -- Bundle GHC runtime dependencies
        putInfo "Bundling GHC runtime libraries..."
        ghcDeps <- getGhcDeps "build/libaletheia-ffi.so"
        forM_ ghcDeps $ \dep ->
            cmd_ "cp" "-L" dep libDir

        -- Patch RUNPATH on all .so files so they find each other via $ORIGIN
        putInfo "Patching RUNPATH on shared libraries..."
        Stdout soFiles <- cmd Shell ("find " ++ libDir ++ " -name '*.so*' -type f")
        forM_ (filter (not . null) (lines soFiles)) $ \f ->
            cmd_ "patchelf" "--set-rpath" "$ORIGIN" f

        -- Create Python venv
        putInfo "Creating Python virtual environment..."
        cmd_ "python3" "-m" "venv" venvDir
        cmd_ venvPip "install" "--upgrade" "pip" "setuptools" "wheel"

        -- Install aletheia Python package (non-editable)
        putInfo "Installing aletheia Python package..."
        cmd_ venvPip "install" "./python"

        -- Find site-packages and write _install_config.py
        Stdout sitePackages <- cmd venvPython "-c"
            "import site; print(site.getsitepackages()[0])"
        let siteDir = strip sitePackages
        let configFile = siteDir </> "aletheia" </> "_install_config.py"
        let soAbsPath = libDir </> "libaletheia-ffi.so"
        putInfo $ "Writing install config: " ++ configFile
        liftIO $ writeFile configFile $
            "from pathlib import Path\n\nLIBRARY_PATH: Path = Path(" ++ show soAbsPath ++ ")\n"

        -- Copy documentation
        putInfo "Copying documentation..."
        cmd_ Shell ("cp -r docs/* " ++ docDir ++ "/")
        -- Copy root doc files that exist
        forM_ ["README.md", "CONTRIBUTING.md", "LICENSE.md", "LICENSE"] $ \f -> do
            rootDocExists <- doesFileExist f
            when rootDocExists $ cmd_ "cp" f docDir

        -- Copy examples
        putInfo "Copying examples..."
        examplesExist <- doesDirectoryExist "examples"
        when examplesExist $ do
            cmd_ Shell ("cp -r examples/* " ++ exampleDir ++ "/")
            cmd_ Shell ("find " ++ exampleDir ++ " -name '__pycache__' -type d -exec rm -rf {} + 2>/dev/null || true")

        -- Write manifest for uninstall
        let manifestFile = libDir </> "manifest.txt"
        liftIO $ writeFile manifestFile $ unlines
            [ prefix </> "lib" </> "aletheia"
            , prefix </> "share" </> "doc" </> "aletheia"
            , prefix </> "share" </> "aletheia"
            ]

        -- Optionally configure shell aliases
        when configShell $ do
            putInfo "Configuring shell aliases..."
            let venvActivate     = venvDir </> "bin" </> "activate"
            let venvActivateFish = venvDir </> "bin" </> "activate.fish"
            let marker = "# Added by aletheia install"

            -- bash
            let bashrc = home </> ".bashrc"
            bashExists <- doesFileExist bashrc
            when bashExists $ do
                Stdout bashContent <- cmd Shell ("cat " ++ bashrc)
                unless (marker `isInfixOf` bashContent) $ do
                    liftIO $ appendFile bashrc $ unlines
                        [ "", marker
                        , "alias aletheia-env='source " ++ venvActivate ++ "'"
                        ]
                    putInfo $ "  Added alias to " ++ bashrc

            -- zsh
            let zshrc = home </> ".zshrc"
            zshExists <- doesFileExist zshrc
            when zshExists $ do
                Stdout zshContent <- cmd Shell ("cat " ++ zshrc)
                unless (marker `isInfixOf` zshContent) $ do
                    liftIO $ appendFile zshrc $ unlines
                        [ "", marker
                        , "alias aletheia-env='source " ++ venvActivate ++ "'"
                        ]
                    putInfo $ "  Added alias to " ++ zshrc

            -- fish
            let fishConfig = home </> ".config" </> "fish" </> "config.fish"
            fishExists <- doesFileExist fishConfig
            when fishExists $ do
                Stdout fishContent <- cmd Shell ("cat " ++ fishConfig)
                unless (marker `isInfixOf` fishContent) $ do
                    liftIO $ appendFile fishConfig $ unlines
                        [ "", marker
                        , "alias aletheia-env 'source " ++ venvActivateFish ++ "'"
                        ]
                    putInfo $ "  Added alias to " ++ fishConfig

        -- Success banner
        putInfo ""
        putInfo "════════════════════════════════════════════════════════════════"
        putInfo "  Aletheia installed successfully!"
        putInfo "════════════════════════════════════════════════════════════════"
        putInfo ""
        putInfo $ "  Location: " ++ prefix
        putInfo ""
        putInfo "  Activate the environment:"
        putInfo $ "    bash/zsh: source " ++ venvDir </> "bin" </> "activate"
        putInfo $ "    fish:     source " ++ venvDir </> "bin" </> "activate.fish"
        putInfo ""
        putInfo "  Then use:"
        putInfo "    python3 -c \"from aletheia import AletheiaClient; print('OK')\""
        putInfo ""
        putInfo "  Uninstall:"
        putInfo $ "    " ++ (if prefixEnv /= Nothing then "PREFIX=" ++ prefix ++ " " else "")
              ++ "cabal run shake -- uninstall"
        putInfo ""

    phony "uninstall" $ do
        -- Read PREFIX (default: ~/.local)
        home <- liftIO getHomeDirectory
        prefixEnv <- liftIO $ lookupEnv "PREFIX"
        let prefix = maybe (home </> ".local") id prefixEnv
        let manifestFile = prefix </> "lib" </> "aletheia" </> "manifest.txt"

        manifestExists <- doesFileExist manifestFile
        if manifestExists
            then do
                manifestContent <- liftIO $ readFile manifestFile
                let dirs = filter (not . null) (lines manifestContent)
                forM_ dirs $ \dir -> do
                    dirExists <- doesDirectoryExist dir
                    when dirExists $ do
                        putInfo $ "Removing " ++ dir ++ " ..."
                        liftIO $ removeDirectoryRecursive dir
                -- Clean up empty parent dirs
                let shareAletheiaDir = prefix </> "share" </> "aletheia"
                shareExists <- doesDirectoryExist shareAletheiaDir
                when shareExists $
                    liftIO $ removeDirectoryRecursive shareAletheiaDir
                putInfo ""
                putInfo "Aletheia uninstalled successfully."
                putInfo ""
            else do
                putInfo $ "No manifest found at " ++ manifestFile
                putInfo "Nothing to uninstall."
