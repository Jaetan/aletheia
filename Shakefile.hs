import Development.Shake
import Development.Shake.FilePath
import System.Directory (createDirectoryLink, removePathForcibly, doesDirectoryExist)
import System.Info (os)
import System.Process (readProcess)
import Data.List (isInfixOf)
import Data.Maybe (listToMaybe)
import Data.Char (isSpace)
import Control.Monad (when)
import GHC.Conc (getNumProcessors)

-- | Trim whitespace from both ends of a string
strip :: String -> String
strip = dropWhile isSpace . reverse . dropWhile isSpace . reverse

-- | Extract the mangled MAlonzo name for processJSONLine from generated Haskell
-- Looks for pattern: "d_processJSONLine_XX ::"
extractMangledName :: String -> Maybe String
extractMangledName content =
    listToMaybe [name | line <- lines content,
                        "processJSONLine" `isInfixOf` line,
                        "::" `isInfixOf` line,
                        let name = takeWhile (/= ' ') (dropWhile (== ' ') line),
                        "d_processJSONLine_" `isInfixOf` name]

-- | Extract the function name currently used in the FFI wrapper
-- Looks for pattern: "Agda.d_processJSONLine_XX"
extractFFIName :: String -> Maybe String
extractFFIName content =
    listToMaybe [cleaned | line <- lines content,
                           "Agda." `isInfixOf` line,
                           "processJSONLine" `isInfixOf` line,
                           let parts = words line,
                           name <- parts,
                           "Agda.d_processJSONLine_" `isInfixOf` name,
                           let cleaned = drop 5 name, -- drop "Agda."
                           "d_processJSONLine_" `isInfixOf` cleaned]

-- | Check that the FFI wrapper uses the correct mangled name
checkFFIName :: FilePath -> FilePath -> Action ()
checkFFIName malonzoFile ffiFile = do
    malonzoContent <- liftIO $ readFile malonzoFile
    ffiContent <- liftIO $ readFile ffiFile

    case (extractMangledName malonzoContent, extractFFIName ffiContent) of
        (Just generatedName, Just ffiName) ->
            when (generatedName /= ffiName) $ do
                putError $ unlines
                    [ ""
                    , "════════════════════════════════════════════════════════════════"
                    , "ERROR: MAlonzo function name mismatch!"
                    , "════════════════════════════════════════════════════════════════"
                    , ""
                    , "  Generated by Agda:  " ++ generatedName
                    , "  Currently in FFI:   " ++ ffiName
                    , ""
                    , "The Agda code structure changed, causing MAlonzo to generate"
                    , "a different mangled name. Update the FFI wrapper to match."
                    , ""
                    , "To fix, run:"
                    , "  sed -i 's/" ++ ffiName ++ "/" ++ generatedName ++ "/g' " ++ ffiFile
                    , ""
                    , "Then rebuild:"
                    , "  cabal run shake -- build"
                    , ""
                    , "════════════════════════════════════════════════════════════════"
                    , ""
                    ]
                error "FFI name mismatch - see above for fix instructions"
        (Nothing, _) ->
            putWarn "Could not extract mangled name from MAlonzo output (might be OK if function signature changed)"
        (_, Nothing) ->
            putWarn "Could not extract function name from FFI wrapper (might be OK if imports changed)"

main :: IO ()
main = shakeArgs shakeOptions{shakeFiles="build", shakeThreads=0, shakeChange=ChangeModtimeAndDigest} $ do

    phony "build" $ do
        need ["build/libaletheia-ffi.so"]

    phony "build-agda" $ do
        need ["build/MAlonzo/Code/Aletheia/Main.hs"]

    phony "build-haskell" $ do
        need ["build/libaletheia-ffi.so"]

    phony "check-properties" $ do
        putInfo "Type-checking Properties modules (proofs)..."
        cores <- liftIO getNumProcessors
        let rtsFlags = ["+RTS", "-N" ++ show cores, "-RTS"]
        let agdaWithRTS mod' = cmd_ (Cwd "src") "agda" (rtsFlags ++ [mod'])
        -- Parser and protocol proofs
        agdaWithRTS "Aletheia/Parser/Properties.agda"
        agdaWithRTS "Aletheia/Protocol/JSON/Properties.agda"
        -- CAN encoding and batch proofs
        agdaWithRTS "Aletheia/CAN/Encoding/Properties.agda"
        agdaWithRTS "Aletheia/CAN/Batch/Properties.agda"
        -- DBC proofs
        agdaWithRTS "Aletheia/DBC/Properties.agda"
        -- LTL proofs (bisimilarity transitively checks CoalgebraBisim and StepResultBisim)
        agdaWithRTS "Aletheia/LTL/JSON/Properties.agda"
        agdaWithRTS "Aletheia/LTL/Bisimilarity.agda"
        putInfo "All Properties modules type-checked successfully!"

    phony "install-python" $ do
        need ["build/libaletheia-ffi.so"]
        cmd_ (Cwd "python") "pip3 install -e ."

    phony "clean" $ do
        putInfo "Cleaning build artifacts..."
        removeFilesAfter "build" ["//*"]
        removeFilesAfter "src" ["//*.agdai"]
        removeFilesAfter "haskell-shim" ["//MAlonzo"]
        cmd_ (Cwd "haskell-shim") "cabal clean"

    "build/MAlonzo/Code/Aletheia/Main.hs" %> \out -> do
        agdaSources <- getDirectoryFiles "src" ["//*.agda"]
        need (map ("src" </>) agdaSources)

        -- Shake's ChangeModtimeAndDigest tracks file content hashes
        -- When any .agda source changes, Shake detects it and re-runs this rule
        -- Agda will then update .agdai files as needed based on source changes
        putInfo "Compiling Agda to Haskell (this may take a few minutes)..."
        cores <- liftIO getNumProcessors
        cmd_ (Cwd "src")
            "agda"
            "+RTS" ("-N" ++ show cores) "-RTS"
            "--compile"
            "--compile-dir=../build"
            "--ghc-dont-call-ghc"
            "Aletheia/Main.agda"

        exists <- doesFileExist out
        if exists
            then do
                putInfo $ "MAlonzo output generated: " ++ out
                -- Check that FFI wrapper uses correct mangled name
                checkFFIName out "haskell-shim/src/AletheiaFFI.hs"
            else error $ "Agda compilation failed: " ++ out ++ " not created"

    phony "create-symlink" $ do
        need ["build/MAlonzo/Code/Aletheia/Main.hs"]

        let symlinkPath = "haskell-shim/MAlonzo"
        let target = "../build/MAlonzo"

        -- Remove existing symlink/directory if present
        liftIO $ removePathForcibly symlinkPath

        putInfo $ "Creating symlink: " ++ symlinkPath ++ " -> " ++ target

        if os == "mingw32"
            then cmd_ "cmd" "/c" "mklink /D" symlinkPath target
            else liftIO $ createDirectoryLink target symlinkPath

    "build/libaletheia-ffi.so" %> \out -> do
        -- Depend on all MAlonzo generated Haskell files
        -- This ensures Shake detects any changes from Agda compilation
        malonzoFiles <- getDirectoryFiles "build" ["MAlonzo//**/*.hs"]
        need (map ("build" </>) malonzoFiles)

        need ["create-symlink"]  -- Depend on phony target, not directory
        need ["haskell-shim/src/AletheiaFFI.hs", "haskell-shim/aletheia.cabal"]

        -- Force Cabal to rebuild when MAlonzo files change
        -- Touch AletheiaFFI.hs to invalidate Cabal's cache
        putInfo "Invalidating Cabal cache (touch AletheiaFFI.hs)..."
        cmd_ "touch" "haskell-shim/src/AletheiaFFI.hs"

        -- Delete intermediate build artifacts to force relink
        putInfo "Cleaning Cabal build artifacts..."
        cmd_ (Cwd "haskell-shim") "rm" "-rf" "dist-newstyle/build/x86_64-linux/ghc-9.6.7/aletheia-0.3.0.0/f/aletheia-ffi"

        putInfo "Building FFI shared library..."
        cmd_ (Cwd "haskell-shim") "cabal" "build" "-j" "aletheia-ffi"

        -- Find and copy the built .so file
        Stdout soPath <- cmd (Cwd "haskell-shim") Shell
            "find dist-newstyle -name 'libaletheia-ffi.so' -type f | head -1"
        let trimmedPath = strip soPath
        if null trimmedPath
            then error "Could not find libaletheia-ffi.so in dist-newstyle"
            else do
                cmd_ (Cwd "haskell-shim") "cp" trimmedPath ("../" ++ out)
                putInfo $ "Shared library created: " ++ out
