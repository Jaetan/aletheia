# Session State: Proof Branch 2 - Coalgebraic Bisimilarity

**Last Updated**: 2026-01-02
**Branch**: `proof-branch-2-behavior-bisim`
**Parent Commit**: `1c56588`
**Status**: Design decision point - awaiting clarification on proof goal

---

## Current Status Summary

**What we've built** (‚úÖ Complete):
1. ‚úÖ **StepResultBisim.agda** - Structural equality for StepResult observations
2. ‚úÖ **CoalgebraBisim.agda** - Coinductive coalgebra bisimilarity record
3. ‚úÖ **CoalgebraSimple.agda** - Proof of concept for Atomic formulas

**What we've discovered** (üìã Documented):
1. üìã Delay.Bisimilarity from stdlib is NOT applicable (wrong abstraction level)
2. üìã LTLProc = LTL formula is too simple (doesn't track evaluation state)
3. üìã **Key insight**: Must avoid Delay Bool to prevent propositional equality issues

---

## Critical Design Decision Point

**User guidance**: "evaluateLTLOnTrace is likely wrong: we do not want to touch Delay Bool, as this will force us to use propositional equality somewhere."

**Implication**: We should NOT compare to evaluateLTLOnTrace! Instead, both coalgebras should be step-based (return StepResult).

**Open question**: What are the two coalgebras we're proving bisimilar?

Options:
1. Two different step-based implementations of LTL semantics
2. stepEval with different predicates/configurations
3. stepEval compared to reference/specification coalgebra
4. Properties of stepEval expressed as coalgebraic bisimilarity

**Status**: Awaiting user clarification on proof goal and coalgebra definitions.

---

## Files Created This Session

### Core Infrastructure (Complete)

1. **src/Aletheia/LTL/StepResultBisim.agda** (73 lines)
   - CounterexampleEquiv: structural equality for counterexamples
   - StepResultBisim: parameterized by state relation R
   - Defines structural equality for finite observations
   - No coinduction at this level (StepResult is finite)

2. **src/Aletheia/LTL/CoalgebraBisim.agda** (65 lines)
   - CoalgebraBisim record: coinductive, generic over S1 S2
   - relate field: bisimulation relation between states
   - step-bisim field: related states produce bisimilar observations
   - Coinduction happens here (for Continue states)

### Exploration and Analysis

3. **src/Aletheia/LTL/Coalgebra.agda** (138 lines)
   - Documents design challenges with LTLProc = LTL formula
   - Identifies need for evaluation state (not just formula structure)
   - Commented out skeleton implementations

4. **src/Aletheia/LTL/CoalgebraSimple.agda** (176 lines)
   - Proof of concept for Atomic formulas only
   - Shows bisimilarity works for simple case
   - Identifies challenges for temporal operators
   - Proves stepL-atomic ‚â° stepM-atomic for atomic formulas

### Documentation

5. **/tmp/stdlib-bisimilarity-exploration.md** - Stdlib exploration results
6. **/tmp/ltlproc-design-challenge.md** - Design challenges documented
7. **/tmp/revised-understanding.md** - Interpretation after user guidance

---

## Key Insights from Exploration

### Insight 1: Delay.Bisimilarity is NOT the right tool
- It's for comparing `Delay A` computations, not `StepResult` coalgebras
- We needed custom StepResultBisim (which we've now defined)
- This was the RIGHT decision!

### Insight 2: StepResult bisimilarity is SIMPLER than Delay bisimilarity
- No bind reasoning needed
- No thunk extensionality needed
- Just structural equality of observations
- Coinduction happens at coalgebra level (CoalgebraBisim), not observation level

### Insight 3: LTLProc representation challenge
- LTL formula alone is insufficient (doesn't track evaluation state)
- For temporal operators: need to track modes (waiting, checking, found, failed)
- This is exactly what LTLEvalState does for state machine!

### Insight 4: Must avoid Delay Bool (user guidance)
- Comparing Delay Bool requires propositional equality
- This leads to extended lambda problems we're trying to avoid
- Both coalgebras should return StepResult, not Delay Bool

---

## Todo List (Updated)

**Completed** (‚úÖ):
1. ‚úÖ Explore stdlib bisimilarity definitions
2. ‚úÖ Check Delay.Bisimilarity
3. ‚úÖ Check Colist
4. ‚úÖ Define StepResult bisimilarity
5. ‚úÖ Define coalgebra bisimilarity record
6. ‚úÖ Test approach with Atomic formulas

**Blocked awaiting clarification** (üöß):
7. üöß Define LTLProc (need to know what second coalgebra is)
8. üöß Define stepL (depends on LTLProc definition)
9. üöß Define relate relation (depends on coalgebra definitions)
10. üöß Prove bisimilarity (depends on all above)

---

## Questions for User

1. **What is the second coalgebra?**
   - Is it a different implementation of step semantics?
   - Or stepEval with different parameters?
   - Or something else?

2. **What's the proof goal?**
   - Prove two implementations equivalent?
   - Prove properties of stepEval?
   - Prove stepEval matches a specification coalgebra?

3. **Should both coalgebras use LTLEvalState?**
   - Or different state representations?

4. **What does "coinductive semantics" mean here?**
   - If not evaluateLTLOnTrace, what is it?

---

## Files to Read (Context)

**Existing implementations**:
- `src/Aletheia/LTL/Incremental.agda` - State machine (stepEval, LTLEvalState)
- `src/Aletheia/LTL/Coinductive.agda` - evaluateLTLOnTrace (Delay Bool - avoid!)
- `src/Aletheia/LTL/Syntax.agda` - LTL formula definition

**Strategy documents**:
- `/home/nicolas/.claude/plans/proof-branch-2-coalgebraic-strategy.md` - Original strategy
- `/tmp/stdlib-bisimilarity-exploration.md` - Stdlib findings
- `/tmp/ltlproc-design-challenge.md` - Design challenges
- `/tmp/revised-understanding.md` - Current understanding

---

## Git Status

**Branch**: `proof-branch-2-behavior-bisim`
**Uncommitted changes**:
- M .session-state.md (this file)
- ?? src/Aletheia/LTL/StepResultBisim.agda (new)
- ?? src/Aletheia/LTL/CoalgebraBisim.agda (new)
- ?? src/Aletheia/LTL/Coalgebra.agda (new, experimental)
- ?? src/Aletheia/LTL/CoalgebraSimple.agda (new, proof of concept)

**Ready to commit?**: Not yet - waiting for design clarification

---

## What Works Right Now

‚úÖ **StepResultBisim** type-checks and is theoretically sound
‚úÖ **CoalgebraBisim** type-checks and is theoretically sound
‚úÖ **CoalgebraSimple** proves bisimilarity for Atomic formulas
‚úÖ Infrastructure is solid and reusable

‚ùì **Unclear**: What the two coalgebras should be
‚ùì **Blocked**: Can't proceed with full proof without knowing coalgebra definitions

---

## Advantages Over Branch 1 (Still True!)

**Branch 1** (`proof-branch-1-thunk-ext`):
- ‚ùå 12 postulates needed
- ‚ùå Fighting extended lambda nominal inequality
- ‚ùå Complex workarounds with thunk parametrization

**Branch 2** (`proof-branch-2-behavior-bisim`):
- ‚úÖ Coalgebraic reasoning (principled)
- ‚úÖ No Delay Bool comparisons (avoids propositional equality issues)
- ‚úÖ Clean infrastructure (StepResultBisim, CoalgebraBisim)
- ‚úÖ No extended lambda equality problems (uses structural observation equality)
- ‚è∏Ô∏è Waiting for design clarification to proceed

---

## Next Steps (When Clarified)

Once we know what the two coalgebras are:

1. Define LTLProc (second coalgebra state type)
2. Define stepL (second coalgebra step function)
3. Define relate (bisimulation relation between states)
4. Prove step-bisim (related states produce bisimilar observations)
5. Start with Atomic, extend to temporal operators
6. Type-check and build

---

**RESUME POINT**: Awaiting user clarification on:
- What are the two coalgebras?
- What is the proof goal?
- Should we compare stepEval to a specification, or prove properties of stepEval itself?

---

**Last Updated**: 2026-01-02 (after user guidance to avoid Delay Bool)
**Status**: Infrastructure complete, design decision point reached
