# Session State: CAN Encoding/Decoding Proofs

**Branch:** `main`
**Last Updated:** 2026-01-23
**Status:** **All commutativity proofs COMPLETE**

---

## Proof Architecture (5 Layers) - ALL COMPLETE

```
Layer 4: Composition (signal-level)      ✅ COMPLETE
Layer 3: Scaling (ℤ ↔ ℚ)                 ✅ COMPLETE (both directions)
Layer 2: Integer conversion (ℕ ↔ ℤ)      ✅ COMPLETE
Layer 1: Bit operations (BitVec ↔ bytes) ✅ COMPLETE
Layer 0: BitVec primitives (structural)  ✅ COMPLETE
```

---

## Complete Proofs

| Layer | Proof | Description |
|-------|-------|-------------|
| 0 | `testBit-setBit-same/diff` | Structural bit independence |
| 0 | `setBit-setBit-comm` | Disjoint setBit commutes |
| 1 | `extractBits-injectBits-roundtrip` | Bit extraction roundtrip |
| 1 | `injectBits-preserves-disjoint` | Disjoint ranges preserved |
| 1 | **`injectBits-commute`** | **Disjoint bit injections commute** |
| 2 | `fromSigned-toSigned-roundtrip` | ℕ → ℤ → ℕ |
| 2 | `toSigned-fromSigned-roundtrip` | ℤ → ℕ → ℤ |
| 3 | `removeScaling-applyScaling-exact` | ℤ → ℚ → ℤ (exact) |
| 3 | `applyScaling-removeScaling-bounded` | ℚ → ℤ → ℚ (bounded) |
| 4 | `extractSignal-injectSignal-roundtrip-unsigned` | Full unsigned roundtrip |
| 4 | `extractSignal-injectSignal-roundtrip-signed` | Full signed roundtrip |
| **Non-overlap** | **`extract-disjoint-inject-unsigned`** | **Extraction unaffected (unsigned)** |
| **Non-overlap** | **`extract-disjoint-inject-signed`** | **Extraction unaffected (signed)** |
| **Commutativity** | **`injectPayload-commute`** | **Byte-order-independent injection commutes** |
| **Commutativity** | **`injectedFrame-commute`** | **Frame-level injection commutes** |
| **Commutativity** | **`disjoint-signals-commute-unsigned`** | **Two unsigned signals commute** |
| **Commutativity** | **`disjoint-signals-commute-signed`** | **Two signed signals commute** |
| **Commutativity** | **`disjoint-signals-commute-mixed`** | **Unsigned + signed signals commute** |

---

## Completed: Commutativity Proofs

### Write-Set Abstraction (Endianness.agda)

The write-set abstraction lifts bit operations to a level where commutativity is nearly tautological:

```agda
BitWrite : Set
BitWrite = ℕ × Bool

applyWrite : Vec Byte 8 → BitWrite → Vec Byte 8
applyWrites : Vec Byte 8 → List BitWrite → Vec Byte 8
writesOf : ∀ {len} → ℕ → BitVec len → List BitWrite

DiffPos : BitWrite → BitWrite → Set
AllDiffPos : List BitWrite → List BitWrite → Set
AllDistinct : List BitWrite → Set
```

### Key Lemmas (all complete):

1. **`applyWrite-comm`** ✅
   - Two writes at different positions commute

2. **`applyWrites-push`** ✅
   - A single write can be pushed through a list of writes

3. **`applyWrites-comm`** ✅
   - Two disjoint write lists commute

4. **`injectBits≡applyWrites`** ✅
   - `injectBits` equals `applyWrites` of `writesOf`

5. **`disjoint-ranges→AllDiffPos`** ✅
   - Disjoint ranges imply all position pairs differ

6. **`injectBits-commute`** ✅
   - Main theorem: disjoint bit injections commute

### Payload Isomorphism (Endianness.agda)

Factored out byte order handling for uniform proofs:

```agda
isBigEndian : ByteOrder → Bool

payloadIso : ByteOrder → Vec Byte 8 → Vec Byte 8
payloadIso bo bytes = if isBigEndian bo then swapBytes bytes else bytes

payloadIso-involutive : ∀ bo bytes → payloadIso bo (payloadIso bo bytes) ≡ bytes

injectPayload : ∀ {len} → ℕ → BitVec len → ByteOrder → Vec Byte 8 → Vec Byte 8
injectPayload s bits bo payload = payloadIso bo (injectBits (payloadIso bo payload) s bits)

injectPayload-commute : ... → disjoint → injectPayload s₂ bits₂ bo (injectPayload s₁ bits₁ bo payload)
                                        ≡ injectPayload s₁ bits₁ bo (injectPayload s₂ bits₂ bo payload)
```

### Signal-Level Commutativity (Properties.agda)

```agda
injectedFrame-commute : ... → SignalsDisjoint sig₁ sig₂
  → injectedFrame n₂ sig₂ bo (injectedFrame n₁ sig₁ bo frame ...)
  ≡ injectedFrame n₁ sig₁ bo (injectedFrame n₂ sig₂ bo frame ...)

disjoint-signals-commute-unsigned :
  ∀ ... → SignalsDisjoint sig₁ sig₂
  → (injectSignal v₁ sig₁ bo frame >>= λ f₁ → injectSignal v₂ sig₂ bo f₁)
  ≡ (injectSignal v₂ sig₂ bo frame >>= λ f₂ → injectSignal v₁ sig₁ bo f₂)
```

---

## Files Modified

- `src/Aletheia/CAN/Endianness.agda`
  - Write-set abstraction layer (BitWrite, applyWrite, applyWrites, writesOf)
  - Disjointness predicates (DiffPos, AllDiffPos, AllDistinct)
  - All commutativity lemmas complete
  - Payload isomorphism (payloadIso, injectPayload, injectPayload-commute)
  - `isBigEndian` moved here (removed duplicate from Encoding.agda)

- `src/Aletheia/CAN/Encoding.agda`
  - Removed duplicate `isBigEndian` (now imported from Endianness)

- `src/Aletheia/CAN/Encoding/Properties.agda`
  - `injectedFrame` updated to use `injectPayload` abstraction
  - `injectedFrame-commute` proof complete
  - `disjoint-signals-commute-unsigned` proof complete

---

## Key Insights

> "You are proving *how* bits commute instead of *that* they commute."

The correct abstraction:
- `injectBits bytes s bits` = apply a finite map of bit positions → Bool to the frame
- Disjoint write sets commute trivially at this level
- No nested induction, no % / /, no `m≡m%n+[m/n]*n`, no `fromℕ<`

> "The fix is almost always: factor out the isomorphism"

For byte order handling:
- `payloadIso bo` is an involution for any byte order
- `injectPayload` factors out the isomorphism
- Commutativity proof handles all byte orders uniformly (no LittleEndian/BigEndian case split)

---

## Next Steps

Signal commutativity proofs are complete:

- ✅ `injectSignal-reduces-signed` - already existed
- ✅ `disjoint-signals-commute-signed` - two signed signals commute
- ✅ `disjoint-signals-commute-mixed` - one unsigned + one signed signal commute

Remaining work:

1. ~~**Fix roundtrip proof warnings**~~ ✅ Fixed by using `resultOf` helper pattern instead of direct `rewrite`
2. **DBC signal overlap validation** - Check if DBC parsing validates that signals are non-overlapping; add the validation if missing
