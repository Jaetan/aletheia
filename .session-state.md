# Session State: Coalgebraic Bisimilarity Proof - Remaining Time Abstraction

**Branch:** `proof-branch-2-behavior-bisim`
**Last Updated:** 2026-01-03
**Status:** 8/10 operators fully proven, 2 require remaining-time refactoring

**DECISION FOR NEXT SESSION:** Extend StepResult with remaining time (Option A from refactoring plan below). This is the cleanest approach for making time observable in the bisimilarity proof.

---

## Current Achievement: Time Abstraction Breakthrough

### ‚úÖ Completed (8/10 operators)

**Fully proven with NO holes:**
1. **Atomic p** - Base case
2. **Not œÜ** - Propositional negation (3 cases)
3. **And œÜ œà** - Propositional conjunction (9 cases)
4. **Or œÜ œà** - Propositional disjunction (9 cases)
5. **Always œÜ** - Temporal necessity ‚ñ°œÜ (3 cases)
6. **Eventually œÜ** - Temporal possibility ‚óáœÜ (3 cases)
7. **Until œÜ œà** - Temporal until œÜ U œà (7 cases)
8. **Next œÜ** - Temporal next ‚óØœÜ (modal states: waiting/active, 4 cases)

### ‚è≥ Infrastructure Complete, Proofs Have Holes (2/10)

**EventuallyWithin Œî œÜ** and **AlwaysWithin Œî œÜ**:
- ‚úÖ LTLProc constructors with startTime tracking
- ‚úÖ toLTL conversion (extracts static formula)
- ‚úÖ stepL implementation (full time window logic)
- ‚úÖ Relate constructors (quotient over startTime)
- ‚è≥ Bisimilarity proofs (6 holes due to time abstraction issue)

---

## The Critical Insight: Time Is Not Semantic Data

### The Problem

**What went wrong:**
- States store `startTime : ‚Ñï` (when did window start?)
- Relate constructor quantifies over `startTime‚ÇÅ` and `startTime‚ÇÇ`
- Agda refuses to prove `startTime‚ÇÅ ‚â° startTime‚ÇÇ` (correct refusal!)
- Proof attempts fall into structural reasoning about time calculations

**Why Agda is right to refuse:**
- Two states with same remaining budget but different start times ARE bisimilar
- startTime is bookkeeping (intensional), not semantics (extensional)
- Metric temporal logic requires quotienting by remaining time, not timestamps

### The Solution: Remaining Time as Observable

**Current (intensional):**
```agda
EventuallyWithinState : ‚Ñï ‚Üí LTLEvalState ‚Üí LTLEvalState  -- stores startTime
```

**Correct (extensional):**
```agda
-- Option A: Add remaining to StepResult
data StepResult (S : Set) : Set where
  Continue : ‚Ñï ‚Üí S ‚Üí StepResult S  -- remaining time + state
  Violated : Counterexample ‚Üí StepResult S
  Satisfied : StepResult S

-- Option B: Compute remaining on demand (pure function)
remaining : TimedFrame ‚Üí ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï  -- curr, windowMicros, startTime ‚Üí remaining
remaining curr windowMicros startTime =
  let actualStart = if startTime ‚â°·µá 0 then timestamp curr else startTime
      elapsed = timestamp curr ‚à∏ actualStart
  in windowMicros ‚à∏ elapsed
```

**Relate constructor (future):**
```agda
eventually-within-relate : ‚àÄ {st : LTLEvalState} {œÜ : LTLProc} {windowMicros remaining : ‚Ñï}
  ‚Üí Relate st œÜ
  ‚Üí Relate (EventuallyWithinState remaining st)
           (EventuallyWithinProc windowMicros remaining œÜ)
  -- No startTime! Only remaining budget matters.
```

---

## Required Refactoring for Bounded Operators

### Phase 1: Make Remaining Time Observable (Choose One)

**Option A: Extend StepResult (cleanest)**
```agda
-- In Incremental.agda
data StepResult (S : Set) : Set where
  Continue : ‚Ñï ‚Üí S ‚Üí StepResult S  -- NEW: remaining time
  Violated : Counterexample ‚Üí StepResult S
  Satisfied : StepResult S

-- Impact: All stepEval/stepL calls return remaining with Continue
-- Benefit: Time is explicit observable, bisim proof is trivial
-- Cost: Update all Continue pattern matches (50+ locations)
```

**Option B: Add Remaining Helper (incremental)**
```agda
-- In Coalgebra.agda and Incremental.agda
remainingTime : TimedFrame ‚Üí ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï
remainingTime curr windowMicros startTime = ...

-- Relate constructor uses remaining as witness
eventually-within-relate : ‚àÄ {st œÜ windowMicros startTime‚ÇÅ startTime‚ÇÇ}
  ‚Üí (remaining : ‚Ñï)
  ‚Üí remainingTime curr windowMicros startTime‚ÇÅ ‚â° remaining
  ‚Üí remainingTime curr windowMicros startTime‚ÇÇ ‚â° remaining
  ‚Üí Relate st œÜ
  ‚Üí Relate (EventuallyWithinState startTime‚ÇÅ st)
           (EventuallyWithinProc windowMicros startTime‚ÇÇ œÜ)

-- Impact: Requires proving remaining equality at each step
-- Benefit: Minimal changes to existing code
-- Cost: More complex proofs
```

### Phase 2: Update State Representations

**Current (bookkeeping-based):**
```agda
EventuallyWithinState : ‚Ñï ‚Üí LTLEvalState ‚Üí LTLEvalState  -- startTime
AlwaysWithinState : ‚Ñï ‚Üí LTLEvalState ‚Üí LTLEvalState      -- startTime
```

**Future (budget-based):**
```agda
EventuallyWithinState : ‚Ñï ‚Üí LTLEvalState ‚Üí LTLEvalState  -- remaining
AlwaysWithinState : ‚Ñï ‚Üí LTLEvalState ‚Üí LTLEvalState      -- remaining

-- Update on each step:
newRemaining = oldRemaining ‚à∏ 1  -- or compute from elapsed
```

### Phase 3: Update Bisimilarity Proofs

With remaining time as observable, proofs become straightforward:

```agda
step-bisim (eventually-within-relate {remaining = r} rel) prev curr
  with stepEval ... | stepL ...
... | Continue r‚ÇÅ st' | Continue r‚ÇÇ œÜ'
  with r‚ÇÅ ‚âü r‚ÇÇ
... | yes refl = continue-bisim (eventually-within-relate rel)  -- Same budget!
... | no _ = {!!}  -- Impossible: identical time calculations

-- No structural reasoning about startTime!
-- Just compare remaining budgets directly.
```

---

## Current File State

### Modified Files

**src/Aletheia/LTL/Coalgebra.agda** (254 lines):
- LTLProc is proper data type (not type alias)
- NextWaiting/NextActive constructors for modal state
- EventuallyWithin/AlwaysWithin constructors with startTime tracking
- Full stepL implementations for all 10 operators
- toLTL conversion function for monitor interop

**src/Aletheia/LTL/Bisimilarity.agda** (622 lines, 6 holes):
- Relate relation with constructors for all 10 operators
- step-bisim proven for 8 operators (no holes)
- EventuallyWithin/AlwaysWithin proofs have 6 holes:
  1-2. EventuallyWithin Violated: frame-eq, reason-eq
  3. EventuallyWithin Continue+Satisfied: absurd case
  4-5. AlwaysWithin Violated: frame-eq, reason-eq
  6. AlwaysWithin Continue+Violated: absurd case
- CRITICAL DOCUMENTATION at lines 88-103 explaining time abstraction issue

### Compilation Status

‚úÖ **Main.agda compiles** (holes are allowed, postulates are not with --safe)
‚ö†Ô∏è **Bisimilarity.agda has 6 holes** (documented, not blocking compilation)
‚úÖ **All 8 proven operators are complete** (no holes, no postulates)

---

## The Proof Pattern That Works

### Until œÜ œà (Reference Implementation)

```agda
step-bisim (until-relate rel1 rel2) prev curr
  with stepEval (toLTL œà) | stepL œà | step-bisim rel2 prev curr
     | stepEval (toLTL œÜ) | stepL œÜ | step-bisim rel1 prev curr
-- Case split on inner results (œà and œÜ)
-- Use inner bisimilarities to construct outer bisimilarity
-- 7 valid cases + 12 impossible = 19 total
```

**Key points:**
1. Evaluate inner formulas separately
2. Get bisimilarity for each inner formula
3. Case split on inner results
4. Construct outer bisimilarity from inner ones
5. Mark impossible cases with ()

### Next œÜ (Modal State Pattern)

```agda
-- Waiting mode: just skip
step-bisim (next-waiting-relate rel) prev curr
  = continue-bisim (next-active-relate rel)

-- Active mode: evaluate inner, use its bisimilarity
step-bisim (next-active-relate rel) prev curr
  with stepEval (toLTL œÜ) | stepL œÜ | step-bisim rel prev curr
... | Continue _ | Continue _ | continue-bisim rel' = continue-bisim (next-active-relate rel')
... | Violated _ | Violated _ | violated-bisim ceq = violated-bisim ceq
... | Satisfied | Satisfied | satisfied-bisim = satisfied-bisim
```

**Key insight:** Modal constructors in LTLProc mirror monitor states exactly.

### Why EventuallyWithin/AlwaysWithin Don't Work Yet

**Problem:** Time window check is if-then-else, Agda won't normalize through it
**Root cause:** startTime is in the STATE, not computed on demand
**Solution:** Make remaining time OBSERVABLE (not bookkeeping)

---

## Next Steps (Priority Order)

### Immediate: Document and Checkpoint

1. ‚úÖ Update Bisimilarity.agda with time abstraction documentation (DONE)
2. ‚úÖ Update .session-state.md with current status (THIS FILE)
3. Commit current state:
```bash
git add -A
git commit -m "feat(LTL): Document remaining-time abstraction for bounded operators

8/10 operators fully proven with coalgebraic bisimilarity.
EventuallyWithin/AlwaysWithin infrastructure complete but proofs
require remaining-time refactoring to avoid structural reasoning.

Key insight: startTime is bookkeeping, not semantic. States should
carry remaining budget, not absolute timestamps. This is the correct
abstraction for metric temporal logic bisimilarity.

See Bisimilarity.agda lines 88-103 for refactoring plan."
```

### Short Term: Complete Bounded Operators

**Choose refactoring approach:**
- Option A: Extend StepResult with remaining time (cleanest, more work)
- Option B: Add remaining helper + witness (incremental, complex proofs)

**Estimated effort:** 2-4 hours
- Update StepResult definition
- Update all Continue patterns (~50 locations)
- Update stepEval/stepL for bounded operators
- Update Relate constructors
- Complete 6 holes in bisimilarity proofs

### Medium Term: Verification and Testing

1. Prove all 10 operators bisimilar (close 6 holes)
2. Update success comment in Bisimilarity.agda
3. Verify compositional proof works for complex nested formulas
4. Update PROJECT_STATUS.md with Phase 3 completion

---

## Key Theoretical Results

### Compositionality Theorem (Proven for 8/10 operators)

**For ANY formula œÜ built from {Atomic, Not, And, Or, Always, Eventually, Until, Next}:**

The bisimilarity proof is constructible by structural recursion on œÜ.

**Example:**
```agda
-- Formula: Always (Not (Next (And (Atomic p) (Atomic q))))
-- Monitor state: AlwaysState (NotState (NextActive (AndState AtomicState AtomicState)))
-- Coalgebra proc: AlwaysProc (NotProc (NextActiveProc (AndProc (AtomicProc p) (AtomicProc q))))
-- Proof: always-relate (not-relate (next-active-relate (and-relate atomic-relate atomic-relate)))
```

**No additional proof work needed!** This scales to arbitrarily complex real-world properties.

### No Extended Lambda Postulates

All 8 proven operators use **pure coalgebraic bisimilarity**:
- No postulates for lambda equality
- No axiom K needed
- --safe flag enforced throughout
- Behavioral equivalence, not definitional equality

---

## Files Summary

**Core proof files:**
- `src/Aletheia/LTL/Bisimilarity.agda` - Main proof (622 lines, 8 operators complete)
- `src/Aletheia/LTL/Coalgebra.agda` - Defunctionalized semantics (254 lines)
- `src/Aletheia/LTL/Incremental.agda` - Monitor implementation (308 lines)
- `src/Aletheia/LTL/CoalgebraBisim.agda` - Generic coalgebra bisimilarity (66 lines)
- `src/Aletheia/LTL/StepResultBisim.agda` - Bisimilarity for observations (78 lines)

**Total:** ~1330 lines of verified bisimilarity proof infrastructure

---

## Recovery Instructions for Next Session

### To Resume Work

1. **Check branch:**
```bash
git status  # Should show: On branch proof-branch-2-behavior-bisim
```

2. **Read this file** to understand current state

3. **Choose refactoring approach** for bounded operators:
   - Read Bisimilarity.agda lines 88-103 for options
   - Decide: extend StepResult or add remaining helper

4. **Start refactoring:**
   - If StepResult: Update Incremental.agda StepResult definition
   - If helper: Add remainingTime function to both implementations
   - Update Relate constructors
   - Update bisimilarity proofs

5. **Verify:**
```bash
cd src
agda +RTS -N32 -RTS Aletheia/LTL/Bisimilarity.agda  # Should type-check with holes
agda +RTS -N32 -RTS Aletheia/Main.agda              # Should compile fully
```

### If Stuck

**Reference implementations:**
- Until proof (lines 359-403): Shows how to handle complex operators
- Next proof (lines 422-451): Shows modal state pattern
- Always/Eventually (lines 262-332): Shows temporal operator pattern

**Key insight to remember:**
> Time is not semantic data. Remaining budget is the only observable.
> States should expose remaining time, not compute it from bookkeeping.

---

## Philosophical Notes

### What This Proof Demonstrates

**Defunctionalization works for temporal logic:**
- LTL semantics as "how it reacts" not "what it means"
- Operational coalgebra ‚â° coinductive semantics
- No extended lambda hacks needed

**Behavioral equivalence is the right abstraction:**
- Compare observations (StepResult), not representations
- Quotient by unobservable structure (startTime)
- Stay at coalgebra level, never fall to term structure

**Metric temporal logic requires care:**
- Time must be observable, not bookkeeping
- Remaining budget vs absolute timestamps
- This is why MTL verification is hard!

### Success Metrics

**Phase 1:** ‚úÖ Core temporal operators (8/10) - COMPLETE
**Phase 2:** ‚è≥ Bounded operators (2/10) - Infrastructure done, proofs need remaining-time refactoring
**Phase 3:** Future - Full verification + performance optimization

**Goal:** Prove all 10 LTL operators bisimilar, demonstrating that the incremental monitor is correct by construction.

---

## References

**Key documents:**
- `docs/EXTENDED_LAMBDA_GUIDE.md` - Why we use coalgebras (not extended lambda equality)
- `~/.claude/plans/zany-popping-spark.md` - Plan for Next operator (modal state pattern)
- This file - Current status and remaining work

**Research references:**
- Chapman et al. (2015) "Quotienting the Delay Monad by Weak Bisimilarity"
- Metric Temporal Logic literature on remaining-time semantics

---

**End of session state. Next: Remaining-time refactoring for bounded operators.** üöÄ
