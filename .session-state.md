# Session State: Coalgebraic Bisimilarity Proof

**Branch:** `proof-branch-2-behavior-bisim`
**Last Updated:** 2026-01-02
**Status:** Major milestone achieved - 6 of 10 LTL operators proven

---

## Current Point in Proof

### ‚úÖ Completed Operators (6/10)

Bisimilarity **fully proven** for:

1. **Atomic p** - Base case (evaluates predicate at current frame)
2. **Not œÜ** - Propositional negation (3 cases + 6 impossible)
3. **And œÜ œà** - Propositional conjunction (9 valid cases + 12 impossible)
4. **Or œÜ œà** - Propositional disjunction (9 valid cases + 12 impossible)
5. **Always œÜ** - Temporal necessity ‚ñ°œÜ (3 cases + 6 impossible)
6. **Eventually œÜ** - Temporal possibility ‚óáœÜ (3 cases + 6 impossible)

### üîÑ Remaining Operators (4/10)

**Next:** Requires modal state extension
- LTLProc needs "waiting vs active" mode
- Monitor uses `NextState` (waiting) and `NextActive` (after skip)
- Defunctionalized version needs equivalent state tracking

**Until œÜ œà:** Straightforward extension
- Similar pattern to And (check both subformulas)
- Coalgebra already defined in Coalgebra.agda
- Monitor already implemented in Incremental.agda
- Just needs Relate constructor and proof cases

**EventuallyWithin/AlwaysWithin:** Need time tracking
- Requires startTime field in LTLProc representation
- Currently LTLProc = LTL (TimedFrame ‚Üí Bool) (no extra state)
- May need to enrich LTLProc to carry runtime state

---

## Key Theoretical Discovery: COMPOSITIONALITY

**Critical Insight:** The proof is **fully compositional**!

For ANY formula œÜ built from `{Atomic, Not, And, Or, Always, Eventually}`:
- Bisimilarity relation constructible via structural recursion
- No additional proof work needed for nested formulas
- Scales to arbitrarily complex real-world LTL properties

**Example:**
```agda
-- Formula: Always (Not (Eventually (And (Atomic p) (Atomic q))))
-- Monitor state: AlwaysState (NotState (EventuallyState (AndState AtomicState AtomicState)))
-- Coalgebra proc: Always (Not (Eventually (And (Atomic p) (Atomic q))))
-- Relation proof: always-relate (not-relate (eventually-relate (and-relate atomic-relate atomic-relate)))
```

This demonstrates that the proof **works at scale** for production formulas!

---

## Critical Bug Fixes (Discovered During Proof!)

### Monitor And/Or Helper State Preservation Bugs

**Fixed in:** `src/Aletheia/LTL/Incremental.agda`

**Before (WRONG):**
```agda
-- And: Right satisfied, left continues
stepEval-and-helper (Continue st1') Satisfied st1 _ = Continue (AndState st1' st1)
-- Uses st1 (left state) twice! Should preserve right state st2.

-- And: Left satisfied, right continues
stepEval-and-helper Satisfied (Continue st2') _ st2 = Continue (AndState st2 st2')
-- Uses st2 (right state) twice! Should preserve left state st1.
```

**After (CORRECT):**
```agda
-- And: Right satisfied, left continues
stepEval-and-helper (Continue st1') Satisfied _ st2 = Continue (AndState st1' st2)
-- Correctly preserves right state st2

-- And: Left satisfied, right continues
stepEval-and-helper Satisfied (Continue st2') st1 _ = Continue (AndState st1 st2')
-- Correctly preserves left state st1
```

**Impact:** Would have caused incorrect re-evaluation at future frames. Discovered because monitor diverged from coalgebra semantics during bisimilarity proof.

**Similar fix applied to Or helper.**

---

## Files Modified

### Core Proof Files

1. **src/Aletheia/LTL/Bisimilarity.agda** (343 lines)
   - Complete bisimilarity proof for 6 operators
   - Relate relation with 6 constructors
   - step-bisim proof covering all cases
   - Verification comments demonstrating compositionality

2. **src/Aletheia/LTL/Incremental.agda**
   - Fixed And/Or helper state preservation bugs
   - Parameterized StepResult by state type S
   - All uses updated to `StepResult LTLEvalState`

3. **src/Aletheia/LTL/StepResultBisim.agda**
   - Parameterized over two state types S1, S2
   - Generic relation R : S1 ‚Üí S2 ‚Üí Set
   - No changes needed (already generic)

4. **src/Aletheia/LTL/CoalgebraBisim.agda**
   - Updated for parameterized StepResult
   - Changed to Set‚ÇÅ for universe level correctness
   - Removed --sized-types (incompatible with --safe)

5. **src/Aletheia/LTL/Coalgebra.agda**
   - Defunctionalized stepL semantics (already complete)
   - No changes this session (was from previous work)

6. **src/Aletheia/Protocol/StreamState.agda**
   - Updated handleStepResult signature to `StepResult LTLEvalState`

### Verification

All files compile successfully:
```bash
cd src && agda Aletheia/Main.agda  # ‚úÖ Type-checks
```

---

## Next Steps (Priority Order)

### Immediate: Prove Until œÜ œà

**Why first:** Straightforward extension, similar to And/Or pattern.

**What to do:**
1. Import `Until` from Syntax and `UntilState` from Incremental
2. Add `until-relate` constructor to Relate relation:
   ```agda
   until-relate : ‚àÄ {st1 st2 : LTLEvalState} {œÜ œà : LTLProc}
     ‚Üí Relate st1 œÜ ‚Üí Relate st2 œà
     ‚Üí Relate (UntilState st1 st2) (Until œÜ œà)
   ```
3. Add proof case to step-bisim:
   - Check œà first (satisfaction condition)
   - If œà satisfied ‚Üí Until satisfied
   - If œà violated/continues, check œÜ (waiting condition)
   - If œÜ violated ‚Üí Until violated
   - If both continue ‚Üí Until continues

**Monitor behavior (Incremental.agda:200-215):**
```agda
stepEval (Until œÜ œà) eval (UntilState st1 st2) prev curr
  with stepEval œà eval st2 prev curr
... | Satisfied = Satisfied
... | Continue st2'
  with stepEval œÜ eval st1 prev curr
... | Violated ce = Violated ce
... | Continue st1' = Continue (UntilState st1' st2')
... | Satisfied = Continue (UntilState st1 st2')
stepEval (Until œÜ œà) eval (UntilState st1 st2) prev curr | Violated _
  with stepEval œÜ eval st1 prev curr
... | Violated ce = Violated ce
... | Continue st1' = Continue (UntilState st1' st2)
... | Satisfied = Continue (UntilState st1 st2)
```

**Coalgebra behavior (Coalgebra.agda:116-128):**
```agda
stepL (Until œÜ œà) prev curr
  with stepL œà prev curr
... | Satisfied = Satisfied
... | Continue œà'
  with stepL œÜ prev curr
... | Violated ce = Violated ce
... | Continue œÜ' = Continue (Until œÜ' œà')
... | Satisfied = Continue (Until œÜ œà')
stepL (Until œÜ œà) prev curr | Violated _
  with stepL œÜ prev curr
... | Violated ce = Violated ce
... | Continue œÜ' = Continue (Until œÜ' œà)
... | Satisfied = Continue (Until œÜ œà)
```

**Expected proof cases:** ~12 valid combinations + impossible cases

### Medium Priority: Next œÜ

**Challenge:** Requires modal state extension in LTLProc.

**Current issue:**
- Monitor has two states: `NextState st` (waiting) and `NextActive st` (evaluating)
- Coalgebra currently simplified: `stepL (Next œÜ) = Continue (Next œÜ)` (always returns same)
- Need to add "mode" to LTLProc

**Two approaches:**

**Option 1:** Enrich LTLProc with state
```agda
data LTLProc : Set where
  AtomicProc : (TimedFrame ‚Üí Bool) ‚Üí LTLProc
  NotProc : LTLProc ‚Üí LTLProc
  -- ... other constructors
  NextWaiting : LTLProc ‚Üí LTLProc  -- Waiting to skip first frame
  NextActive : LTLProc ‚Üí LTLProc   -- Evaluating after skip
```

**Option 2:** Use mode flag
```agda
data NextMode : Set where
  Waiting : NextMode
  Active : NextMode

-- Then Next carries mode:
NextProc : NextMode ‚Üí LTLProc ‚Üí LTLProc
```

**Recommendation:** Option 1 (explicit constructors) - cleaner, matches monitor structure.

**What to do:**
1. Extend LTLProc in Coalgebra.agda with NextWaiting/NextActive
2. Update stepL to pattern match on mode
3. Add two Relate constructors: next-waiting-relate and next-active-relate
4. Prove bisimilarity for both modes

### Low Priority: Bounded Temporal Operators

**EventuallyWithin/AlwaysWithin** need startTime tracking.

**Challenge:** LTLProc needs to carry runtime state (startTime : ‚Ñï).

**Defer until:** After Next and Until are proven. These are less commonly used in practice.

---

## Important Context

### Why This Proof Approach Works

**The Extended Lambda Problem:** Extended lambdas at different source locations are nominally distinct, blocking equality proofs.

**Our Solution:** Never prove definitional equality! Use coalgebraic bisimilarity instead.

**Key Principles:**
1. Define stepL : LTLProc ‚Üí Frame ‚Üí StepResult (how it reacts)
2. NOT ‚ü¶ œÜ ‚üß : Stream Frame ‚Üí Set (what it means)
3. Compare OBSERVATIONS (StepResult), not internal representations
4. Prove behavioral equivalence via Relate relation

**Result:** No extended lambdas in entire proof! No postulates needed!

### Proof Architecture

```
CoalgebraBisim (Generic coalgebra bisimilarity)
    ‚Üì
Relate : LTLEvalState ‚Üí LTLProc ‚Üí Set
    ‚Üì
step-bisim : Relate st proc ‚Üí StepResultBisim (stepEval st) (stepL proc)
    ‚Üì
Structural recursion on formula constructors
```

**Why it's compositional:**
- always-relate and eventually-relate take ANY relation rel : Relate st œÜ
- Recursive call to step-bisim proves inner formula's bisimilarity
- Outer formula's bisimilarity follows from inner's
- By induction, works for ALL formulas built from proven operators

### Impossible Cases Pattern

When patterns don't match, bisim proof is impossible:
```agda
... | Violated _ | Satisfied | ()  -- Left violated, right satisfied, can't be bisimilar
```

Agda proves impossibility via unification - no manual work needed!

---

## Git Status

**Current commits:**
```
309e038 feat(LTL): Prove bisimilarity for Eventually, demonstrate compositionality
f9e3bca fix(LTL): Fix monitor And/Or helpers, prove bisimilarity for propositional operators
1f92a12 feat(LTL): Complete Always (Atomic p) bisimilarity proof (tagged: proof-coalgebra-bisim-base-case)
```

**Tagged milestones:**
- `proof-coalgebra-bisim-base-case` - Always (Atomic p) proven
- Current work builds on this foundation

---

## Testing and Verification

**Type-checking:**
```bash
cd src
agda Aletheia/LTL/Bisimilarity.agda  # ‚úÖ Type-checks with warnings (unreachable clauses in And - expected)
agda +RTS -N32 -RTS Aletheia/Main.agda  # ‚úÖ Full compilation succeeds
```

**Warnings:** Unreachable clauses in And proof (some impossible cases overlap) - safe to ignore.

---

## Resources and References

**Key Files to Reference:**
- `src/Aletheia/LTL/Bisimilarity.agda` - Current proof (343 lines)
- `src/Aletheia/LTL/Incremental.agda` - Monitor implementation
- `src/Aletheia/LTL/Coalgebra.agda` - Defunctionalized semantics
- `docs/EXTENDED_LAMBDA_GUIDE.md` - Why we use coalgebras

**Proof Strategy Document:** `~/.claude/plans/cosmic-spinning-axolotl.md`

**Research Reference:** Chapman et al. (2015) "Quotienting the Delay Monad by Weak Bisimilarity" - uses similar extensionality approach

---

## Recovery Instructions for Next Session

**To resume work:**

1. **Check branch:**
   ```bash
   git status  # Should show: On branch proof-branch-2-behavior-bisim
   ```

2. **Read this file** to understand current state

3. **Start with Until proof:**
   - Import Until, UntilState
   - Add until-relate constructor
   - Add step-bisim case (similar to And pattern)
   - Type-check: `agda src/Aletheia/LTL/Bisimilarity.agda`

4. **If stuck, reference:**
   - Monitor behavior: Incremental.agda lines 200-215
   - Coalgebra behavior: Coalgebra.agda lines 116-128
   - And proof for pattern: Bisimilarity.agda lines 108-154

5. **Commit after Until proven:**
   ```bash
   git add -A
   git commit -m "feat(LTL): Prove bisimilarity for Until œÜ œà"
   ```

---

## Success Metrics

**Phase 1 Complete:** ‚úÖ Core temporal operators (6/10)
**Phase 2 In Progress:** Until, Next
**Phase 3 Deferred:** Bounded operators (EventuallyWithin, AlwaysWithin)

**Goal:** Prove bisimilarity for all 10 LTL operators, demonstrating that the incremental monitor is behaviorally equivalent to the coinductive LTL semantics.

**Why it matters:** This proves the monitor implementation is correct by construction, with no postulates, no extended lambda hacks, and pure coalgebraic reasoning!

---

## Notes

- ‚úÖ No extended lambda equality issues encountered
- ‚úÖ No postulates needed for proven operators
- ‚úÖ All proofs use --safe --without-K flags
- ‚úÖ Proof scales compositionally to nested formulas
- ‚ö†Ô∏è Unreachable clause warnings in And (expected, safe to ignore)
- üéØ Next operator (Until) should take ~30-60 minutes
- üéØ Next+Until together unlocks full LTL fragment for real-world use

**End of session state. Ready to resume!** üöÄ
