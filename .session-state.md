# Session State: CAN Encoding/Decoding Proofs

**Branch:** `main`
**Last Updated:** 2026-01-24
**Status:** **All commutativity proofs COMPLETE, DBC validation COMPLETE**

---

## Proof Architecture (5 Layers) - ALL COMPLETE

```
Layer 4: Composition (signal-level)      ✅ COMPLETE
Layer 3: Scaling (ℤ ↔ ℚ)                 ✅ COMPLETE (both directions)
Layer 2: Integer conversion (ℕ ↔ ℤ)      ✅ COMPLETE
Layer 1: Bit operations (BitVec ↔ bytes) ✅ COMPLETE
Layer 0: BitVec primitives (structural)  ✅ COMPLETE
```

---

## Complete Proofs

| Layer | Proof | Description |
|-------|-------|-------------|
| 0 | `testBit-setBit-same/diff` | Structural bit independence |
| 0 | `setBit-setBit-comm` | Disjoint setBit commutes |
| 1 | `extractBits-injectBits-roundtrip` | Bit extraction roundtrip |
| 1 | `injectBits-preserves-disjoint` | Disjoint ranges preserved |
| 1 | **`injectBits-commute`** | **Disjoint bit injections commute** |
| 2 | `fromSigned-toSigned-roundtrip` | ℕ → ℤ → ℕ |
| 2 | `toSigned-fromSigned-roundtrip` | ℤ → ℕ → ℤ |
| 3 | `removeScaling-applyScaling-exact` | ℤ → ℚ → ℤ (exact) |
| 3 | `applyScaling-removeScaling-bounded` | ℚ → ℤ → ℚ (bounded) |
| 4 | `extractSignal-injectSignal-roundtrip-unsigned` | Full unsigned roundtrip |
| 4 | `extractSignal-injectSignal-roundtrip-signed` | Full signed roundtrip |
| **Non-overlap** | **`extract-disjoint-inject-unsigned`** | **Extraction unaffected (unsigned)** |
| **Non-overlap** | **`extract-disjoint-inject-signed`** | **Extraction unaffected (signed)** |
| **Commutativity** | **`injectPayload-commute`** | **Byte-order-independent injection commutes** |
| **Commutativity** | **`injectedFrame-commute`** | **Frame-level injection commutes** |
| **Commutativity** | **`disjoint-signals-commute-unsigned`** | **Two unsigned signals commute** |
| **Commutativity** | **`disjoint-signals-commute-signed`** | **Two signed signals commute** |
| **Commutativity** | **`disjoint-signals-commute-mixed`** | **Unsigned + signed signals commute** |

---

## DBC Signal Validation (COMPLETE)

Decidable signal overlap validation for DBC files, handling multiplexed signals correctly.

### Key Types (DBC/Properties.agda)

```agda
-- Two signals' bit ranges don't overlap
data SignalsDisjoint (sig₁ sig₂ : SignalDef) : Set where
  disjoint-left  : s₁ + l₁ ≤ s₂ → SignalsDisjoint sig₁ sig₂
  disjoint-right : s₂ + l₂ ≤ s₁ → SignalsDisjoint sig₁ sig₂

signalsDisjoint? : (sig₁ sig₂ : SignalDef) → Dec (SignalsDisjoint sig₁ sig₂)

-- Two signals can be active at the same time
data CanCoexist : SignalPresence → SignalPresence → Set where
  both-always      : CanCoexist Always Always
  always-left      : CanCoexist Always (When m v)
  always-right     : CanCoexist (When m v) Always
  different-mux    : m₁ ≢ m₂ → CanCoexist (When m₁ v₁) (When m₂ v₂)
  same-mux-same-val: m₁ ≡ m₂ → v₁ ≡ v₂ → CanCoexist (When m₁ v₁) (When m₂ v₂)
  -- Note: same mux, different value = mutually exclusive (can't coexist)

canCoexist? : (p₁ p₂ : SignalPresence) → Dec (CanCoexist p₁ p₂)

-- A signal pair is valid if: mutually exclusive OR disjoint when coexisting
data SignalPairValid (sig₁ sig₂ : DBCSignal) : Set where
  mutually-exclusive    : ¬ CanCoexist ... → SignalPairValid sig₁ sig₂
  disjoint-when-coexist : CanCoexist ... → SignalsDisjoint ... → SignalPairValid sig₁ sig₂

signalPairValid? : (sig₁ sig₂ : DBCSignal) → Dec (SignalPairValid sig₁ sig₂)

-- All pairwise signal combinations in a message are valid
data AllSignalPairsValid : List DBCSignal → Set

-- Signal range consistency (only non-trivial runtime check)
SignalRangeConsistent : DBCSignal → Set  -- minimum ≤ maximum
signalRangeConsistent? : (sig : DBCSignal) → Dec (SignalRangeConsistent sig)

-- Complete message validity (pairs + ranges)
data MessageValid (msg : DBCMessage) : Set
messageValid? : (msg : DBCMessage) → Dec (MessageValid msg)

-- Full DBC validation
DBCValid : DBC → Set
dbcValid? : (dbc : DBC) → Dec (DBCValid dbc)
```

### Key Design Decisions

1. **Dec over Bool**: Decidable predicates provide proof evidence automatically
2. **K-compatible CanCoexist**: Carries equalities as data (`m₁ ≡ m₂ → v₁ ≡ v₂ → ...`) instead of forcing index unification
3. **Triangular check**: Each signal checked against all following signals (O(n²/2))
4. **Multiplexed signal handling**: Same mux + different value = mutually exclusive (no overlap check needed)
5. **No redundant checks**: startBit < 64, bitLength ≤ 64, dlc ≤ 8 guaranteed by Fin types
6. **Range consistency**: Only non-trivial runtime check (`minimum ≤ maximum`) uses Dec ℚ._≤?_

---

## Files Modified

- `src/Aletheia/CAN/Endianness.agda`
  - Write-set abstraction layer (BitWrite, applyWrite, applyWrites, writesOf)
  - Disjointness predicates (DiffPos, AllDiffPos, AllDistinct)
  - All commutativity lemmas complete
  - Payload isomorphism (payloadIso, injectPayload, injectPayload-commute)
  - `isBigEndian` moved here (removed duplicate from Encoding.agda)

- `src/Aletheia/CAN/Encoding.agda`
  - Removed duplicate `isBigEndian` (now imported from Endianness)

- `src/Aletheia/CAN/Encoding/Properties.agda`
  - `injectedFrame` updated to use `injectPayload` abstraction
  - `injectedFrame-commute` proof complete
  - All signal commutativity proofs complete (unsigned, signed, mixed)
  - Roundtrip warnings fixed using `resultOf` helper pattern

- `src/Aletheia/DBC/Properties.agda`
  - `SignalsDisjoint` and `signalsDisjoint?`
  - `CanCoexist` and `canCoexist?` (K-compatible)
  - `SignalPairValid` and `signalPairValid?`
  - `AllSignalPairsValid` and `allSignalPairsValid?`
  - `DBCValid` and `dbcValid?` (renamed from DBCSignalsValid)
  - `ValidationError` type and `findDBCError` for specific failure messages
  - `validateDBC : DBC → String ⊎ DBCValid dbc`

- `src/Aletheia/DBC/JSONParser.agda`
  - Refactored to return `String ⊎ DBC` with contextual error messages
  - Error messages include message/signal names and specific field failures
  - `parseDBCWithErrors` is the primary interface; `parseDBC` wraps for compatibility

- `src/Aletheia/Protocol/StreamState.agda`
  - `handleParseDBC-State` now uses `parseDBCWithErrors` → `validateDBC` pipeline
  - Returns detailed error on parse failure or validation failure

---

## Key Insights

> "You are proving *how* bits commute instead of *that* they commute."

The correct abstraction:
- `injectBits bytes s bits` = apply a finite map of bit positions → Bool to the frame
- Disjoint write sets commute trivially at this level
- No nested induction, no % / /, no `m≡m%n+[m/n]*n`, no `fromℕ<`

> "The fix is almost always: factor out the isomorphism"

For byte order handling:
- `payloadIso bo` is an involution for any byte order
- `injectPayload` factors out the isomorphism
- Commutativity proof handles all byte orders uniformly (no LittleEndian/BigEndian case split)

> "Use Dec, not Bool, for validation that needs proof evidence"

For DBC validation:
- `Dec P` gives you `P` or `¬P` as proof evidence
- No need for users to "provide proofs" - computed automatically
- `⌊ dec ⌋` converts to Bool for backwards compatibility

> "Carry equalities as data to work under --without-K"

For indexed families like `CanCoexist`:
- Can't pattern match when indices need to unify (`same-mux-same-val m v : CanCoexist (When m v) (When m v)`)
- Solution: carry equalities explicitly (`same-mux-same-val : m₁ ≡ m₂ → v₁ ≡ v₂ → CanCoexist (When m₁ v₁) (When m₂ v₂)`)

---

## Next Steps

All core verification infrastructure is complete:

1. ✅ Signal commutativity proofs (unsigned, signed, mixed)
2. ✅ Roundtrip proof warnings fixed
3. ✅ DBC signal overlap validation with multiplexed signal support
4. ✅ Signal extraction error distinction (ValueOutOfBounds with actual values)
5. ✅ LTL bisimilarity complete (all 13 operators proven)
6. ✅ Obsolete TODOs cleaned up in Coalgebra.agda
7. ✅ DBC Proof extraction: `lookupSignalPairValid`, `extractDisjointness`, `lookupDisjointFromDBC`
8. ✅ extract-disjoint-inject proofs (unsigned, signed) - already complete, TODOs updated

**Proof audit complete. All proofs from Steps 1-2 done.**

Optional future work:

1. **Store DBCValid proof in StreamState**: Change `dbc : Maybe DBC` to `Maybe (Σ DBC DBCValid)` to enable proof extraction at runtime
2. **Batch operation proofs** (optional): extractAllSignals-complete, buildFrame-non-corruption
