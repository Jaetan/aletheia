# Session State: Coalgebraic Bisimilarity Proof

**Branch:** `proof-branch-2-behavior-bisim`
**Last Updated:** 2026-01-03
**Status:** Major milestone achieved - 7 of 10 LTL operators proven

---

## Current Point in Proof

### ‚úÖ Completed Operators (7/10)

Bisimilarity **fully proven** for:

1. **Atomic p** - Base case (evaluates predicate at current frame)
2. **Not œÜ** - Propositional negation (3 cases + 6 impossible)
3. **And œÜ œà** - Propositional conjunction (9 valid cases + 12 impossible)
4. **Or œÜ œà** - Propositional disjunction (9 valid cases + 12 impossible)
5. **Always œÜ** - Temporal necessity ‚ñ°œÜ (3 cases + 6 impossible)
6. **Eventually œÜ** - Temporal possibility ‚óáœÜ (3 cases + 6 impossible)
7. **Until œÜ œà** - Temporal until œÜ U œà (7 valid cases + 12 impossible, refactored to flat with-patterns)

### üîÑ Remaining Operators (3/10)

**Next œÜ:** Requires modal state extension
- LTLProc needs "waiting vs active" mode
- Monitor uses `NextState` (waiting) and `NextActive` (after skip)
- Defunctionalized version needs equivalent state tracking

**EventuallyWithin/AlwaysWithin:** Need time tracking
- Requires startTime field in LTLProc representation
- Currently LTLProc = LTL (TimedFrame ‚Üí Bool) (no extra state)
- May need to enrich LTLProc to carry runtime state

---

## Key Theoretical Discovery: COMPOSITIONALITY

**Critical Insight:** The proof is **fully compositional**!

For ANY formula œÜ built from `{Atomic, Not, And, Or, Always, Eventually, Until}`:
- Bisimilarity relation constructible via structural recursion
- No additional proof work needed for nested formulas
- Scales to arbitrarily complex real-world LTL properties

**Example:**
```agda
-- Formula: Always (Not (Eventually (And (Atomic p) (Atomic q))))
-- Monitor state: AlwaysState (NotState (EventuallyState (AndState AtomicState AtomicState)))
-- Coalgebra proc: Always (Not (Eventually (And (Atomic p) (Atomic q))))
-- Relation proof: always-relate (not-relate (eventually-relate (and-relate atomic-relate atomic-relate)))
```

This demonstrates that the proof **works at scale** for production formulas!

---

## Critical Bug Fixes (Discovered During Proof!)

### Monitor And/Or Helper State Preservation Bugs

**Fixed in:** `src/Aletheia/LTL/Incremental.agda`

**Before (WRONG):**
```agda
-- And: Right satisfied, left continues
stepEval-and-helper (Continue st1') Satisfied st1 _ = Continue (AndState st1' st1)
-- Uses st1 (left state) twice! Should preserve right state st2.

-- And: Left satisfied, right continues
stepEval-and-helper Satisfied (Continue st2') _ st2 = Continue (AndState st2 st2')
-- Uses st2 (right state) twice! Should preserve left state st1.
```

**After (CORRECT):**
```agda
-- And: Right satisfied, left continues
stepEval-and-helper (Continue st1') Satisfied _ st2 = Continue (AndState st1' st2)
-- Correctly preserves right state st2

-- And: Left satisfied, right continues
stepEval-and-helper Satisfied (Continue st2') st1 _ = Continue (AndState st1 st2')
-- Correctly preserves left state st1
```

**Impact:** Would have caused incorrect re-evaluation at future frames. Discovered because monitor diverged from coalgebra semantics during bisimilarity proof.

**Similar fix applied to Or helper.**

### Until Operator Refactoring (Nested ‚Üí Flat With-Patterns)

**Motivation:** Nested with-clauses in original Until implementation prevented clean bisimilarity proof due to Agda's with-abstraction type constraints.

**Before (nested with-clauses):**
```agda
stepEval (Until œÜ œà) eval (UntilState st1 st2) prev curr
  with stepEval œà eval st2 prev curr
... | Satisfied = Satisfied
... | Continue st2'
  with stepEval œÜ eval st1 prev curr
... | Violated ce = Violated ce
... | Continue st1' = Continue (UntilState st1' st2')
```

**After (flat with-patterns):**
```agda
stepEval (Until œÜ œà) eval (UntilState st1 st2) prev curr
  with stepEval œà eval st2 prev curr | stepEval œÜ eval st1 prev curr
-- œà satisfied ‚Üí Until satisfied (œÜ result doesn't matter)
... | Satisfied | _ = Satisfied
-- œà continues, œÜ violated ‚Üí Until violated
... | Continue st2' | Violated ce = Violated ce
-- œà continues, œÜ continues ‚Üí Until continues
... | Continue st2' | Continue st1' = Continue (UntilState st1' st2')
```

**Changes Applied To:**
- `src/Aletheia/LTL/Incremental.agda` - Monitor implementation
- `src/Aletheia/LTL/Coalgebra.agda` - Defunctionalized coalgebra

**Semantic Equivalence:** Both versions have identical behavior. The flat version evaluates both œÜ and œà in parallel (no short-circuiting when œà satisfies), which is semantically equivalent to the nested version but structurally simpler.

**Benefit for Proof:** Flat with-patterns match the And/Or proof pattern, enabling straightforward bisimilarity proof with 7 valid cases + 12 impossible cases.

---

## Files Modified

### Core Proof Files

1. **src/Aletheia/LTL/Bisimilarity.agda** (425 lines)
   - Complete bisimilarity proof for 7 operators
   - Relate relation with 7 constructors
   - step-bisim proof covering all cases
   - Verification comments demonstrating compositionality

2. **src/Aletheia/LTL/Incremental.agda**
   - Fixed And/Or helper state preservation bugs
   - Refactored Until operator to flat with-patterns
   - Parameterized StepResult by state type S
   - All uses updated to `StepResult LTLEvalState`

3. **src/Aletheia/LTL/StepResultBisim.agda**
   - Parameterized over two state types S1, S2
   - Generic relation R : S1 ‚Üí S2 ‚Üí Set
   - No changes needed (already generic)

4. **src/Aletheia/LTL/CoalgebraBisim.agda**
   - Updated for parameterized StepResult
   - Changed to Set‚ÇÅ for universe level correctness
   - Removed --sized-types (incompatible with --safe)

5. **src/Aletheia/LTL/Coalgebra.agda**
   - Defunctionalized stepL semantics
   - Refactored Until operator to flat with-patterns (matching monitor)

6. **src/Aletheia/Protocol/StreamState.agda**
   - Updated handleStepResult signature to `StepResult LTLEvalState`

### Verification

All files compile successfully:
```bash
cd src && agda Aletheia/Main.agda  # ‚úÖ Type-checks
```

---

## Next Steps (Priority Order)

### Immediate: Next œÜ

**Challenge:** Requires modal state extension in LTLProc.

**Current issue:**
- Monitor has two states: `NextState st` (waiting) and `NextActive st` (evaluating)
- Coalgebra currently simplified: `stepL (Next œÜ) = Continue (Next œÜ)` (always returns same)
- Need to add "mode" to LTLProc

**Two approaches:**

**Option 1:** Enrich LTLProc with state
```agda
data LTLProc : Set where
  AtomicProc : (TimedFrame ‚Üí Bool) ‚Üí LTLProc
  NotProc : LTLProc ‚Üí LTLProc
  -- ... other constructors
  NextWaiting : LTLProc ‚Üí LTLProc  -- Waiting to skip first frame
  NextActive : LTLProc ‚Üí LTLProc   -- Evaluating after skip
```

**Option 2:** Use mode flag
```agda
data NextMode : Set where
  Waiting : NextMode
  Active : NextMode

-- Then Next carries mode:
NextProc : NextMode ‚Üí LTLProc ‚Üí LTLProc
```

**Recommendation:** Option 1 (explicit constructors) - cleaner, matches monitor structure.

**What to do:**
1. Extend LTLProc in Coalgebra.agda with NextWaiting/NextActive
2. Update stepL to pattern match on mode
3. Add two Relate constructors: next-waiting-relate and next-active-relate
4. Prove bisimilarity for both modes

### Low Priority: Bounded Temporal Operators

**EventuallyWithin/AlwaysWithin** need startTime tracking.

**Challenge:** LTLProc needs to carry runtime state (startTime : ‚Ñï).

**Defer until:** After Next and Until are proven. These are less commonly used in practice.

---

## Important Context

### Why This Proof Approach Works

**The Extended Lambda Problem:** Extended lambdas at different source locations are nominally distinct, blocking equality proofs.

**Our Solution:** Never prove definitional equality! Use coalgebraic bisimilarity instead.

**Key Principles:**
1. Define stepL : LTLProc ‚Üí Frame ‚Üí StepResult (how it reacts)
2. NOT ‚ü¶ œÜ ‚üß : Stream Frame ‚Üí Set (what it means)
3. Compare OBSERVATIONS (StepResult), not internal representations
4. Prove behavioral equivalence via Relate relation

**Result:** No extended lambdas in entire proof! No postulates needed!

### Proof Architecture

```
CoalgebraBisim (Generic coalgebra bisimilarity)
    ‚Üì
Relate : LTLEvalState ‚Üí LTLProc ‚Üí Set
    ‚Üì
step-bisim : Relate st proc ‚Üí StepResultBisim (stepEval st) (stepL proc)
    ‚Üì
Structural recursion on formula constructors
```

**Why it's compositional:**
- always-relate and eventually-relate take ANY relation rel : Relate st œÜ
- Recursive call to step-bisim proves inner formula's bisimilarity
- Outer formula's bisimilarity follows from inner's
- By induction, works for ALL formulas built from proven operators

### Impossible Cases Pattern

When patterns don't match, bisim proof is impossible:
```agda
... | Violated _ | Satisfied | ()  -- Left violated, right satisfied, can't be bisimilar
```

Agda proves impossibility via unification - no manual work needed!

---

## Git Status

**Current commits:**
```
aacefc3 feat(LTL): Prove bisimilarity for Until, refactor to flat with-patterns
65c6884 docs: Save session state - 6 of 10 LTL operators proven with compositionality
309e038 feat(LTL): Prove bisimilarity for Eventually, demonstrate compositionality
f9e3bca fix(LTL): Fix monitor And/Or helpers, prove bisimilarity for propositional operators
```

**Tagged milestones:**
- `proof-coalgebra-bisim-base-case` - Always (Atomic p) proven
- Current work builds on this foundation

---

## Testing and Verification

**Type-checking:**
```bash
cd src
agda Aletheia/LTL/Bisimilarity.agda  # ‚úÖ Type-checks with warnings (unreachable clauses in And - expected)
agda +RTS -N32 -RTS Aletheia/Main.agda  # ‚úÖ Full compilation succeeds
```

**Warnings:** Unreachable clauses in And proof (some impossible cases overlap) - safe to ignore.

---

## Resources and References

**Key Files to Reference:**
- `src/Aletheia/LTL/Bisimilarity.agda` - Current proof (425 lines, 7 operators proven)
- `src/Aletheia/LTL/Incremental.agda` - Monitor implementation (refactored Until)
- `src/Aletheia/LTL/Coalgebra.agda` - Defunctionalized semantics (refactored Until)
- `docs/EXTENDED_LAMBDA_GUIDE.md` - Why we use coalgebras

**Proof Strategy Document:** `~/.claude/plans/cosmic-spinning-axolotl.md`

**Research Reference:** Chapman et al. (2015) "Quotienting the Delay Monad by Weak Bisimilarity" - uses similar extensionality approach

---

## Recovery Instructions for Next Session

**To resume work:**

1. **Check branch:**
   ```bash
   git status  # Should show: On branch proof-branch-2-behavior-bisim
   ```

2. **Read this file** to understand current state

3. **Start with Next proof:**
   - Extend LTLProc in Coalgebra.agda with NextWaiting/NextActive constructors
   - Update stepL to handle both modes
   - Add next-waiting-relate and next-active-relate constructors to Relate
   - Add step-bisim cases for both modes
   - Type-check: `agda src/Aletheia/LTL/Bisimilarity.agda`

4. **If stuck, reference:**
   - Monitor behavior: Incremental.agda (NextState and NextActive)
   - Current coalgebra: Coalgebra.agda (simplified, needs extension)
   - Similar pattern: And/Or proofs in Bisimilarity.agda

5. **Commit after Next proven:**
   ```bash
   git add -A
   git commit -m "feat(LTL): Prove bisimilarity for Next œÜ"
   ```

---

## Success Metrics

**Phase 1 Complete:** ‚úÖ Core temporal operators (7/10)
**Phase 2 In Progress:** Next œÜ
**Phase 3 Deferred:** Bounded operators (EventuallyWithin, AlwaysWithin)

**Goal:** Prove bisimilarity for all 10 LTL operators, demonstrating that the incremental monitor is behaviorally equivalent to the coinductive LTL semantics.

**Why it matters:** This proves the monitor implementation is correct by construction, with no postulates, no extended lambda hacks, and pure coalgebraic reasoning!

---

## Notes

- ‚úÖ No extended lambda equality issues encountered
- ‚úÖ No postulates needed for proven operators
- ‚úÖ All proofs use --safe --without-K flags
- ‚úÖ Proof scales compositionally to nested formulas
- ‚úÖ Until operator refactored to flat with-patterns for clean proof
- ‚ö†Ô∏è Unreachable clause warnings in And/Until (expected, safe to ignore)
- üéØ Next operator (Next œÜ) requires modal state extension in LTLProc
- üéØ Next will complete the core LTL fragment for real-world use

**End of session state. Ready to resume!** üöÄ
