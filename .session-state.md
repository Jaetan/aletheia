# Session State: Layer 4 Composition Proof

**Branch:** `main`
**Last Updated:** 2026-01-20
**Status:** **Layer 4A COMPLETE, Layer 4B signature type-checks (proof has hole)**

---

## Current Task: extractSignal-injectSignal-roundtrip

### Critical Issue Identified: Floor Precision

The original theorem statement has a **fundamental problem**:

```agda
removeScaling value factor offset = just (floor((value - offset) / factor))
```

The `floor` operation loses precision. `applyScaling (removeScaling value ...)` equals `value` **only if `(value - offset) / factor` is already an integer**.

### Corrected Theorem Statement

The theorem should take `raw : ℤ` as input (guaranteeing exact representability):

```agda
extractSignal-injectSignal-roundtrip :
  ∀ (raw : ℤ) (sig : SignalDef) (byteOrder : ByteOrder) (frame : CANFrame)
  → WellFormedSignal sig
  → let value = applyScaling raw (SignalDef.factor sig) (SignalDef.offset sig)
    in inBounds value (SignalDef.minimum sig) (SignalDef.maximum sig) ≡ true
  → fromSigned raw (toℕ (SignalDef.bitLength sig)) < 2 ^ toℕ (SignalDef.bitLength sig)
  → injectSignal value sig byteOrder frame >>= (λ frame' →
      extractSignal frame' sig byteOrder) ≡ just value
```

**Rationale**: Signal values in DBC files ARE exactly representable. The factor/offset define a discrete set:
```
valid_values = { applyScaling(raw, factor, offset) | raw ∈ ℤ, raw fits in bitLength bits }
```

---

## Data Flow Analysis

### injectSignal pipeline
```
value : ℚ  (defined as applyScaling raw factor offset)
  ↓ removeScaling(value, factor, offset)
rawSigned : ℤ  (= raw, by removeScaling-applyScaling-exact)
  ↓ fromSigned(rawSigned, bitLength)
rawUnsigned : ℕ
  ↓ ℕToBitVec(rawUnsigned, bounded)
rawBitVec : BitVec bitLength
  ↓ injectBits(bytes, startBit, rawBitVec)
updatedBytes : Vec Byte 8
  ↓ (optional swapBytes for big-endian)
frame' : CANFrame
```

### extractSignal pipeline (reverse)
```
frame' : CANFrame
  ↓ (optional swapBytes for big-endian)
bytes : Vec Byte 8  (= updatedBytes, by swapBytes-involutive)
  ↓ extractBits(bytes, startBit)
rawBitVec : BitVec bitLength  (= original, by extractBits-injectBits-roundtrip)
  ↓ bitVecToℕ
rawUnsigned : ℕ  (= original, by bitVecToℕ-ℕToBitVec-roundtrip)
  ↓ toSigned(rawUnsigned, bitLength, isSigned)
rawSigned : ℤ  (= raw, by toSigned-fromSigned-roundtrip)
  ↓ applyScaling(rawSigned, factor, offset)
scaledValue : ℚ  (= value, definitionally!)
  ↓ inBounds check
just value
```

---

## Lemmas Required

| Layer | Lemma | Status | Location |
|-------|-------|--------|----------|
| **Endianness** | `swapBytes-involutive` | ✅ | Endianness:147 |
| **1: Bits** | `extractBits-injectBits-roundtrip` | ✅ | Endianness:479 |
| **1.5: ℕ↔BitVec** | `bitVecToℕ-ℕToBitVec-roundtrip` | ✅ | Conversion:366 |
| **2: Integer** | `toSigned-fromSigned-roundtrip` | ✅ | Properties:137 |
| **3: Scaling** | `removeScaling-applyScaling-exact` | ✅ | Properties:416 |
| **4A: Unsigned** | `signal-roundtrip-unsigned` | ✅ | Properties:951 |
| **4A: Signed** | `signal-roundtrip-signed` | ✅ | Properties:977 |
| **Helper** | `SignedFits-implies-fromSigned-bounded` | ✅ | Properties:903 |

### Layer 4B: Full Roundtrip (TODO)

The full `extractSignal-injectSignal-roundtrip` theorem combines:
1. `signal-roundtrip-unsigned/signed` (pure bytes level)
2. `removeScaling-applyScaling-exact` (scaling layer)
3. `swapBytes-involutive` (endianness handling)
4. Bounds propagation (trivial: same value passes same bounds)

---

## Proof Outline

```agda
extractSignal-injectSignal-roundtrip raw sig byteOrder frame wf inBounds-ok fits =
  -- Goal: injectSignal value sig byteOrder frame >>= extractSignal ... ≡ just value
  -- where value = applyScaling raw factor offset

  -- Step 1: Show injectSignal succeeds
  -- removeScaling value factor offset ≡ just raw (by removeScaling-applyScaling-exact)
  -- fromSigned raw bitLength < 2^bitLength (by `fits` hypothesis)
  -- injectSignal value ... ≡ just frame'

  -- Step 2: Show extractSignal returns just value
  -- 2a. swapBytes cancels (by swapBytes-involutive)
  -- 2b. extractBits ∘ injectBits roundtrip (by extractBits-injectBits-roundtrip)
  -- 2c. bitVecToℕ ∘ ℕToBitVec roundtrip (by bitVecToℕ-ℕToBitVec-roundtrip)
  -- 2d. toSigned ∘ fromSigned roundtrip (by toSigned-fromSigned-roundtrip)
  -- 2e. applyScaling raw = value (definitional)
  -- 2f. inBounds check passes (by inBounds-ok)
```

---

## Implementation Approach

### Abstraction Levels

**Level 1: Core roundtrip lemma (no Maybe, no guards)**
```agda
-- Pure roundtrip: given successful injection, extraction recovers value
signal-roundtrip-core :
  ∀ (raw : ℤ) (sig : SignalDef) (byteOrder : ByteOrder) (bytes : Vec Byte 8)
  → (fits : fromSigned raw (toℕ bitLength) < 2 ^ toℕ bitLength)
  → let injectedBytes = injectBits (swapIf byteOrder bytes) startBit (ℕToBitVec (fromSigned raw bitLength) fits)
        extractedBits = extractBits (swapIf byteOrder injectedBytes) startBit
        extractedRaw = toSigned (bitVecToℕ extractedBits) bitLength isSigned
    in extractedRaw ≡ raw
```

**Level 2: Lift through Maybe**
```agda
-- Handle the Maybe monad and guards
extractSignal-injectSignal-roundtrip : (as above)
```

### Key Challenge: Guard Conditions

Both `injectSignal` and `extractSignal` have `if` guards:
- `injectSignal`: checks `inBounds value min max`
- `extractSignal`: checks `inBounds scaledValue min max`

Need to show: if the first guard passes (by hypothesis), the second also passes (because we extract the same value).

---

## Files to Modify

1. **`Properties.agda`**: Add the theorem and proof
2. **`.session-state.md`**: Track progress

---

## Next Steps

1. ✅ Remove outdated TODO (done)
2. ✅ Add `signal-roundtrip-unsigned` lemma (pure bytes level, unsigned case)
3. ✅ Add `signal-roundtrip-signed` lemma (pure bytes level, signed case)
4. ✅ Add `SignedFits-implies-fromSigned-bounded` helper
5. ✅ Add `signalValue` helper function
6. ✅ Add `extractSignal-injectSignal-roundtrip-unsigned` signature (type-checks!)
7. ⏳ Fill in proof body for `extractSignal-injectSignal-roundtrip-unsigned`

---

## Proof Status Summary

| Layer | Status | Notes |
|-------|--------|-------|
| **0: BitVec** | ✅ COMPLETE | 4 proofs |
| **1: Bit Ops** | ✅ COMPLETE | 4 proofs |
| **2: Integer** | ✅ COMPLETE | 3 proofs |
| **3: Scaling** | ✅ COMPLETE | 8 proofs |
| **4A: Core Roundtrip** | ✅ COMPLETE | 2 proofs (unsigned + signed) |
| **4B: Full Roundtrip** | ⏳ SIGNATURE OK | Proof body has hole at line 1070 |
| **Non-Overlap** | ⏳ TODO | Prerequisites ready |

## Key Technical Notes for Next Session

### Implicit Arguments Fix (Critical)
The core roundtrip lemmas required explicit `{bitLength}` arguments:
```agda
extractBits {bitLength} (injectBits {bitLength} bytes startBit bv) startBit
```
Without these, Agda couldn't unify implicit parameters.

### Layer 4B Proof Strategy
The proof body needs to:
1. Unfold `injectSignal` - show it returns `just frame'`
   - bounds-ok: inBounds passes
   - removeScaling-applyScaling-exact: gets back `+ n`
   - n<2^bl: fits check passes
2. Unfold `extractSignal` on `frame'` - show it returns `just value`
   - signal-roundtrip-unsigned: bytes roundtrip
   - swapBytes-involutive: endianness cancels
   - Same value → same bounds check passes

